Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для організації працівників приватного охоронного підприємства.

Студент гр. ПЗПІ-21-8	__________________ Степаненко А. В.
(підпис)
Керівник роботи	__________________ ст.викл. Сокорчук І.П.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Степаненку Артему Віталійовичу
1.	Тема роботи: «Програмна система для організації працівників приватного охоронного підприємства»	
2.	Термін узгодження завдання курсової роботи «01» квітня 2024 р.
3.	Термін здачі студентом закінченої роботи «07» серпня 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
додавання нових користувачів, територій, власників, редагування зазначених охоронців, облік звітів від охоронців. Використовувати ОС Windows 10/11, СКБД Microsoft SQL Server 2019, середовище розробки Microsoft Visual Studio 2022, мова програмування C#	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction Overview Diagram,  Activity Diagram, State Diagram, Component Diagram, Package Diagram	



КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проєкту	15.04.2024	виконано
2	Проєктування програмного
проєкту	20.04.2024	виконано
3	Кодування програмного проєкту	05.05.2024	виконано
4	Оформлення пояснювальної
записки	01.06.2024	виконано
5	Захист курсової роботи	08.06.2024	виконано

Дата видачі завдання «01» квітня 2024 р.
Керівник	__________________ ст.викл. Сокорчук І.П.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-8	                Степаненко А. В.
(підпис)



 
РЕФЕРАТ


	Пояснювальна записка до курсової роботи: 113 с., 28 рис., 2 табл.,4 додатки, 6 джерел.
	АДМІНІСТРАТОР, ВЛАСНИК, ДІЛЯНКА, ЗАМОВЛЕННЯ, ІНВЕНТАР, ОХОРОНА, ПІДПРИЄМСТВО, ПРОГРАМНА СИСТЕМА, РОЛІ, ЗВІТ СИТУАЦІЇ.

	Об’єктом дослідження є бізнес про приватні охоронні підприємства та захист власності, а найактуальніше на теперішній час це організація діяльності охоронців та власників за для забезпечення великого рівня ефективності та безпеки.
	Метою курсової роботи є розробка програмного додатку, системи, яка дозволяє організувати роботу мережі приватних охоронних підприємств за замовленням власника з можливістю написання простих звітів для фіксації ситуації, створювати ділянки у системі як власник, створювати замовлення у системі та корегувати умови, оновлювати дані про зарплатню працівників, керувати інвентарем охоронців, здійснювати моніторинг ситуації на ділянці.
	Методи розробки базуються на використанні серверної технології ASP.NET Core із мовою програмування C#, із базою даних Microsoft SQL Server, веб застосунок або клієнтська частина базується на використанні технологій HTML та CSS, реалізацію розумного пристрою розроблено на мові програмування C++.
	Результатом роботи є здійснення програмної реалізації системи для організації роботи працівників приватного охоронного підприємства та власників, зарахованих до системи. Програмна система складається із сервера, веб-застосунку  та розумного пристрою.
ЗМІСТ

Вступ
1 Аналіз предметної області	9
    1.1 Бізнес-вимоги	9
        1.1.1 Бізнес-можливості	9
        1.1.2 Бізнес-цілі та критерії успіху	11
        1.1.3 Потреби клієнтів або ринку	12
        1.1.4 Бізнес-ризики	13
    1.2 Концепція рішення	14
        1.2.1 Окреслення концепції	14
        1.2.2 Головна функціональність	15
        1.2.3 Припущення та залежності	16
    1.3 Рамки та обмеження проєкту	16
        1.3.1 Рамки первинного випуску	16
        1.3.2 Рамки наступних випусків	19
        1.3.3 Обмеження та винятки	20
    1.4 Бізнес-контекст	20
        1.4.1 Профілі зацікавлених сторін	20
        1.4.2 Пріоритети проєкту	21
        1.4.3 Робоче середовище	23
2 Постановка задачі	24
3 Проєктування бази даних	26
    3.1 Побудова ER-діаграми	26
    3.2 Побудова логічної моделі бази даних на основі ER-діаграми	27
4 Архітектура програмної системи	30
    4.1 Архітектура серверної частини	30
    4.2 Архітектура IoT частини	35
    4.3 Архітектура клієнтської частини	40
5 Опис програмної системи	45
    5.1 Виклик і завантаження	45
    5.2 Призначення і логічна структура	46
    5.3 Опис програмної реалізації	47
Висновки	55
Перелік джерел посилання	56
Додаток А Програмний код серверної частини	57
Додаток Б Програмний код IoT пристрою	67
Додаток В Програмний код клієнтської частини	74
Додаток Г Перевірка на наявність плагіату…………………………………...114

	
	
 
ВСТУП


	Одним із найважливіших аспектів сучасного життя є ефективна організація роботи. Люди хочуть мати можливість швидко, безпечно та надійно координувати свої дії. У цій динамічній реальності традиційні методи управління працівниками охоронних підприємств та власниками ділянок стикаються з численними викликами.
Зростання кількості охоронних завдань та об’єктів призводить до перевантаженості, що збільшує час реагування та підвищує ризики для безпеки. Традиційні методи управління часто виявляються неефективними та витратними. Працівники охорони можуть бути втомленими або неуважними, що може призвести до порушень безпеки. Також виникають проблеми з доступністю охоронних послуг у деяких районах або в певний час доби.
Ще однією проблемою для багатьох користувачів є комунікація з охоронцями та їхня поведінка під час виконання завдань, що може конфліктувати з вимогами клієнта. Також не виключається фактор непорозуміння на основі мови спілкування під час виконання завдань.
Одночасно з цим, штучний інтелект робить значні кроки вперед. Розробляються нові технології, які дозволяють системам самостійно керувати процесами охорони та моніторингу. У цій ситуації автономні системи організації роботи працівників стають перспективним рішенням, що може значно змінити сферу охоронних послуг.
Автономні системи для організації роботи працівників охоронних підприємств, мають потенціал значно підвищити рівень безпеки, оптимізувати робочі процеси, зробити охоронні послуги більш доступними та зручними для клієнтів, а також значно економити час та ресурси підприємств та їх працівників.

Головна мета проекту полягає у створенні ефективної та автоматизованої системи для організації роботи працівників приватного охоронного підприємства та власників ділянок. Система спрямована на точне керування діяльністю працівників, що дозволить покращити якість обслуговування та забезпечити зручність для клієнтів.
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Найбільшими конкурентами у цій галузі організації роботи охоронних підприємств є Topguard.ua, Security Holding та Venbest.
TopGuard.ua — це провідна охоронна компанія в Україні, яка надає широкий спектр охоронних послуг. Компанія має більше 20 років досвіду на ринку охоронних послуг та успішно реалізувала численні міжнародні проекти, що дозволяє їй відповідати європейським нормам і стандартам якості. Серед послуг що надає ця компанія можна приділити увагу охороні об’єктів, особисту охорону, технічну охорону та захист приватності. Основною відмінністю від розроблюваного продукту є відсутність уніфікованого додатку із організацією роботи власного підприємства. Єдиний найближчий приклад є веб-застосунок із контактною базою підприємства та власників.
Security Holding є відомою приватною охоронною компанією в Україні, яка швидко розвивається. Контролює приблизно 15% українського ринку за обсягом послуг, що надаються. За роки існування «Security Holding» реалізував понад 4500 масштабних проектів, забезпечуючи комплексну безпеку підприємств, співробітників і громадян. Компанія охороняє понад 34 400 об'єктів по всій країні. Серед послуг що надає ця компанія можна приділити фізичну безпеку, технічну безпеку та протипожежний захист. Ця компанія так само не має уніфікованого додатку для контролю та організації роботи працівників та власників.
«Venbest» — відома українська охоронна компанія, яка працює понад два десятиліття та надає широкий спектр охоронних послуг по всій Україні. Послуги компанії включають фізичну охорону різноманітних об’єктів, таких як комерційні та житлові будинки, навчальні заклади та промислові об’єкти. Venbest також пропонує послуги особистої безпеки, включаючи послуги особистої охорони та захист транзакцій великої вартості. Крім того, вони пропонують технічні рішення безпеки, такі як системи відеоспостереження, системи сигналізації та системи контролю доступу. На відміну від інших конкурентів, Venbest є більш інноваційним у цій сфері.
Підводячи підсумки з аналізу конкурентів, можна виділити відмінності та переваги нашого розроблюваного продукту:
– можливість організації інвентарю у системі на складі так і для працівника із закріпленням;
– можливість створення власного замовлення власником на своїх умовах;
– працівники можуть залишати прості звіти для подальшого перегляду іншими групами користувачів;
– можливість прямого зв'язку із власником як охоронець.
Наша модель монетизації передбачає отримання прибутку завдяки підвищення коефіцієнту оплати послуг за охорону конкретним охоронцем, або групою охоронців. Плата буде формуватися за формулою розраховуючи оплату охоронців за час роботи.
Клієнтами нашої програмної системи є люди, які потребують ефективної та безпечної організації роботи охоронного підприємства та управління своїми ділянками з мінімальними ризиками та без зайвого турбування. Програмна система орієнтована на використання як у міських, так і в сільських районах. 
Типовим користувачем нашої системи є особа віком від 21 до 55 років, яка бажає ефективно управляти охоронними процесами на своїй ділянці або в межах приватного охоронного підприємства. Такому користувачу буде зручно використовувати веб-застосунок для отримання всієї необхідної інформації про охоронні заходи та їхній стан.
Цільовими ринками розроблюваної системи є:
– населені пункти із великою кількістю бізнесів;
– населені пункти із великою кількістю ділянок необхідних для охорони;
– населені пункти, які потребують охорони ділянок за державним замовленням.
Підходами до маркетингу розроблюваної системи є:
– поширення інформації про наявність системи через інтернет канали, веб сайти, соціальні мережі, реклама за пошуком, знайти нашу цільову аудиторію;
– співпраця із приватними охоронними підприємствами що потребують використання системи із організації роботи працівників;
Стратегіями просування розроблюваної системи є:
– оптимізація сайту і контенту для пошукових систем, щоб забезпечити високу видимість при пошуку інформації про охоронні системи.
– встановлення партнерських відносин з іншими охоронними компаніями, агентствами нерухомості та іншими бізнесами


1.1.2 Бізнес-цілі критерії успіху


БЦ-1: Досягти зниження витрат на обслуговування охоронних послуг на 20% протягом перших двох років використання програмного продукту.
БЦ-2: Охопити не менше двох  нових регіонів протягом першого року впровадження системи на ринку.
БЦ-3: Забезпечити покращення ефективності роботи працівників охоронного підприємства на 35% у порівнянні з традиційними методами управління протягом першого року експлуатації.
БЦ-4: Підвищити задоволеність клієнтів на 20% протягом першого року впровадження завдяки покращенню комунікаційних та аналітичних можливостей системи.
КУ-1: Укласти партнерські угоди з не менше ніж трьома компаніями до кінця першого року роботи продукту.
КУ-2: Досягти реєстрації не менше ніж 3 тисяч активних користувачів і забезпечити мінімум 55% з них як платних клієнтів протягом першого року використання.
КУ-3: Забезпечити приріст прибутку компанії на 35% у порівнянні з попереднім фінансовим роком протягом перших двох років впровадження продукту.
КУ-4: Запровадити не менше п’яти нових функцій у системі протягом першого року використання продукту, включаючи розширені можливості аналітики та автоматизації завдань.
КУ-5: Досягти середнього рейтингу користувачів не нижче 4.5 з 5 за рік та отримати не менше 1,000 позитивних відгуків про систему.


	1.1.3 Потреби клієнтів або ринку


Потреби клієнтів:
– безпека та надійність роботи працівників: клієнти вимагають високого рівню організації працівників та отриманої безпеки ділянки чи об’єкту, наявність механізмів реагування на зміну ситуації під час зміни охоронців. Надійність роботи представляє собою мінімальну ймовірність збою програми та системи та організацію стабільної роботи системи увесь час.
– зручний та ефективний інтерфейс: користувачі потребують простий та зрозумілий інтерфейс для створення ефективної роботи програми та працівників із власником у системі. Потреба також у великому можливому функціоналу системи за яким можливо зробити велику кількість дій не задіяючи інші джерела зв’язку чи розрахунків.
– швидкість реагування: користувачі потребують великої швидкості реагування на зміни ситуації на ділянці. Ціль полягає у розробці стабільного застосунку який швидко зможе сповістити про зміни ситуації як охоронцю, так і власнику.


	1.1.4 Бізнес-ризики


Ризики:
– конкуренція щодо аналогічних розроблюваних систем досить невелика, проте перехід користувачів до нашої системи може зайняти великий час;
– труднощі під час пілотного запуску системи та неправильне розуміння продукту з боку цільової аудиторії;
– недостатній інтерес з боку вже існуючих аналогів через слабку необхідність змінювати вже працюючий процес роботи.
Можливі дії:
– зміна маркетингової стратегії та модернізація існуючої;
– вихід на зв’язок із конкурентами та початкових бізнесів;
– проведення додаткових тестувань застосунку перед запуску пілоту програми;
– надання навчальних курсів працівникам із роботи із системою та роботою охоронцем.


	1.2 Концепція рішення
	1.2.1 Окреслення концепції


Головна ідея проекту полягає у розробці і створенні ефективного додатку який представляє систему із організації роботи працівників роботи приватного охоронного підприємства і власників, що зарахованого до системи. Додаток спрямований на ефективне розподілення ресурсів працівників і власника у роботі із ділянкою чи об’єктом, що дозволить спростити час роботи і підвищити безпеку.
Продукт надасть можливість власнику ділянки у системі легко створювати нові ділянки та замовлення, переглядати інформацію, охоронцю дозволить ефективно модерувати свій інвентар, а адміністраторам – керувати процесами обох груп користувачів. Головна мета полягає у забезпеченні великого рівня безпеки зменшуючи при цьому ресурси охоронців.
Головною особливістю IoT частини проекту є інтеграція інтерфейсу із переглядом звітів системи, переглядом статистики звітів та написання нового звіту не використовуючи веб застосунок.
Основними перевагами проекту вважають надання найбільш ефективного застосування ресурсів охоронців та забезпечення великого рівня безпеки, що задовольняє потреби клієнтів та підвищує рейтинг системи та призводить до підвищення рівню довіри серед користувачів та потенційних партнерів.
Так як однією з головних переваг є забезпечення безпеки, необхідно зазначити критерії безпеки даних користувачів. Усі дані, що використовуються клієнтською частиною (мобільний застосунок або веб сайт), IoT пристроями та серверною частиною системи, шифруються алгоритмами бази даних. Для забезпечення доступу лише тим користувачам, що увійшли до системи, використовуються зовнішні алгоритми аутентифікації та авторизації. Кожен користувач повинен мати унікальній дані для ідентифікації. Звіти роботи програми зберігаються у форматі логів і за допомогою панелі адміністрування готові до аналізу.
Створення даної програмної системи буде сприяти у підвищенні рівнів стандартів індустрії, що означає підвищення якості надання послуг та безпеки. Це стане важливим кроком у покращенні роботи індустрії із охорони ділянок та об’єктів.


	1.2.2 Головна функціональність


ГФ-1: Власники можуть створювати ділянки із власною інформацією для розуміння ризиків;
ГФ-2: Власники можуть створювати власні замовлення із параметрами критеріїв охорони ділянки;
ГФ-3: Програмна система буде автоматично вираховувати зарплатню охоронцю, а також підраховувати фінальний чек до сплати власнику включаючи усіх зарахованих охоронців;
ГФ-4: Програмна система автоматично вираховує прибуток системи за допомогою зміни коефіцієнтів;
ГФ-5: Охоронці можуть переглядати увесь інвентар що зараховано до підприємства і закріплювати його за собою для забезпечення безпеки на ділянці;
ГФ-6: Охоронці та власники можуть переглядати записані звіти до замовлення для аналізу та фіксації ситуації на теперішній час;
ГФ-7: Користувачі мають можливість звертання до технічної підтримки із вирішенням проблем із системою чи сприйняттям інтерфейсу.


	1.2.3 Припущення та залежності


П-1: Клієнти готові купити пакет послуг з охорони.
П-2: Наявність підтримуваної платформи розміщення програми та стабільне інтернет з’єднання
П-3: Будівля, де будуть встановлюватися датчики, має проходити усі тести безпеки для їх встановлення.
З-1: Постійна підтримка з боку адміністратора щодо встановлення потрібних співробітників на потрібний об’єкт
З-2: Робота охоронних підприємств повинна курируватися спецслужбами країни, а також відповідати усім стандартам із законодавства країни.


	1.3 Рамки та обмеження проекту
	1.3.1 Рамки первинного випуску


Серверна частина повинна включати:
– реалізацію алгоритмів реєстрації користувачів та авторизацію у систему із підтримкою ролей та правами доступу;
– реалізацію алгоритмів змін даних про замовлення власника ділянки та видалення;
– реалізацію алгоритмів змін даних про ділянку, що занесено до системи власником;
– можливість створення замовлення на своїх умовах власником;
– шифрування даних користувача за допомогою алгоритмів бази даних та бібліотек  для підтримки додаткової безпеки;
– наявність механізмів для резервного копіювання даних і у випадку аварійних ситуацій, програма має мати механізми із завантаженням резервної копії бази даних до системи;
– використання ефективних алгоритмів зв’язку із базою даних та задіювати мінімум ресурсів та забезпечувати велику ефективність;
– розподілення архітектури для ефективного використання даних системи, включати можливості зміни бази даних, додавання нових даних до системи;
– реалізацію архітектури що буде готова до нових змін у системі чи змін, задіяючи старі ресурси системи;
– зв’язок із окремими частинами має включати можливість отримання і відправки даних у форматі JSON за допомогою API.
IoT частина повинна включати:
– збір даних необхідних для роботи частини та відправка даних до серверної частини;
– аналіз отриманих даних від серверної частини та відображення аналізованих даних користувачеві;
– усі дані які відправляються чи отримуються пристроєм повинні проходити через стандарт протоколу HTTPS;
Front-end частина повинна включати:
– наявність алгоритмів та інтерфейсі реєстрації та авторизації із аутентифікацією користувача, використання безпечних шляхів збереження даних та шифрування;
– алгоритми із створенням, редагуванням, видаленням інформації замовлення власника;
– алгоритми створення, перегляду, редагування інформації про ділянку, яка була створення власником;
– реалізацію експорту вихідних даних у файл формату PDF для подальшого використання користувачем;
– алгоритми і інтерфейси створення, редагування, видалення інформації про інвентар, що залучено до охоронця;
– алгоритми і інтерфейси перегляду наявних замовлень та зарахування до нього охоронцем за бажанням чи шляхом прямого зарахування через панель адміністрування;
– алгоритми і інтерфейси реалізації панелі адміністрування із можливим функціоналом редагування, видалення, перегляду, додавання даних системи.
– механізми щодо використання валідації та перевірки даних введеним користувачем до системи перед відправленням і збереженням до сервера;
– використання HTTPS протоколу зв’язку між компонентами системи та користувачем;
– захист від доступу до даних через клієнт що не розпізнано через вікно авторизації.
Мобільна частина повинна включати:
– функціонал аутентифікації до мобільного додатку через дві ролі – власник та охоронець;
– алгоритми із переглядом, редагуванням та створенням даних про звіт від охоронця;
– алгоритми із переглядом, створенням та редагуванням замовлення із боку власника;
– алгоритми із переглядом, створенням та редагуванням даних про ділянку із боку власника;
– зв’язок із базою даних повинен використовувати протокол зв’язку HTTPS;
– захист від доступу до даних через клієнт що не розпізнано через вікно авторизації.


	1.3.2 Рамки наступних випусків


Серверна частина частина може включати:
– реалізацію нових алгоритмів статистики із підрахунком рівня небезпеки на ділянці, підрахунок рекомендованої кількості охоронців та рекомендований інвентар для охоронців;
– покращення бази даних з боку введення нових даних, наприклад, додавання функціоналу для реалізації відгуків від користувачів, чатів.
IoT частина може включати:
– розширений функціонал існуючого пристрою шляхом додавання нових алгоритмів;
– реалізацію нових пристроїв із датчиками фіксації диму, металошукач, датчик підрахунку інтенсивності потоку людей до території;
Front-End частина може включати:
– реалізацію функціоналу оплати послуг на певний період часу;
– покращення існуючого функціоналу пошуку та фільтрації даних;
– реалізацію нових елементів ведення статистики, графіків про роботу охоронців, про зріст оплати, тощо;
– детальний огляд доступний і зайнятих територій охоронцями використовуючи інтерактивну карту із даними та статистикою.


	1.3.3 Обмеження та винятки


– для забезпечення роботи із системою необхідне підключення до мережі Інтернет з боку сервера та з боку користувача. При відсутності інтернет з’єднання система не буде працювати повністю;
– для забезпечення звітів у системі, охоронці повинні мати обставини про їх написання. При умовах небезпечної ситуації, до програми можуть не надходити нові звіти, бо автоматизація від охоронців не передбачена;
– оплата за послуги може змінюватися через зміну умов контракту працівників та контракту із власником. Також охоронців може стати як більше на замовленні, так і менше.


1.4 Бізнес-контекст
	1.4.1 Профілі зацікавлених сторін


Профілі зацікавлених сторін проекту наведені в таблиці 1.1.
Таблиця 1.1 – Профілі зацікавлених сторін проекту
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Клієнт	Уніфікований інтерфейс для взаємодії із охороною	Відношення як до партнера – можливий розрив контракту через незадоволення послугами	Ідея єдиної програми для контролю за охоронною системою	Стабільне інтернет з’єднання
Інвестори	Можлива монополія через чудову ідею	Бізнес проект який має усю успішність	Фінансовий прибуток, контроль над важливою галуззю	Законодавчі обмеження
Співробітники	Можливість навчання при працевлаштуванні	Робота із перспективним майбутнім	Фінансовий прибуток, добре ставлення до робітників ніж у конкурентів	Обов’язкові знання та готовність до ризику


	1.4.2 Пріоритети проекту


Пріоритети проекту наведені в таблиці 1.2

Таблиця 1.2 – Пріоритети проекту
Показники	Виконання(етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Продукт має бути готовим до випуску до 10.06.2024 		можливе відхилення від графіку не більше ніж на 30 днів.
Функціональність			У першому запуску повинен повинен бути основний працюючий функціонал (70%)
Якість			У версії релізу програма повинна пройти усі тестування
Персонал		Максимальний розмір команди: 1 розробник та 1-2 адміністратори	
Ціна			Допустиме перевищення на 15%


	
1.4.3 Робоче середовище


Програмна система повинна обслуговувати користувачів з інших країн і саме тому необхідно зазначити використання хмарних технологій. За для забезпечення стабільності у цьому проекті буде використовувати Microsoft Azure.
Для збереження даних користувача слід використовувати сумісну базу даних, наприклад Microsoft SQL Server. Доступ до даних через серверну частину буде зроблено за допомогою Entity Framework Core.
За для написання складного проекту слід використати фреймворк серверної частини та мову програмування. Для потреб розроблюваної системи було обрано мову C# та фреймворк ASP.NET, що забезпечить високу сумісність із хмарними сервісами.
Для розробки користувацького інтерфейсу було використано HTML із власноруч написаним CSS.
Для реалізації датчиків IoT-частини продукту було обрано мову програмування C++ для подальшого розміщення на пристрої.
Для забезпечення безпеки запитів IoT пристроїв слід використовувати шифрування за допомогою HTTPS, а також слід використати доступні інструменти із авторизацією за допомогою ASP.NET Authentication.

 
2 ПОСТАНОВКА ЗАДАЧІ


	Аналізуючи результати аналізу предметної області, задачею курсовою роботи було поставлено створення програмної системи для організації роботи працівників приватного охоронного підприємства та власників.
	База даних повинна мати функціонал та інформацію про: користувачів, ролі користувачів, інвентар, замовлення, ділянки, звіти охоронців.
	Для власника має бути реалізований наступний функціонал:
	– реєстрація та аутентифікація з авторизацією у системі;
	– перегляд інформації про ділянку та створення нової із можливістю видалення;
	– створення замовлення, редагування замовлення та видалення, перегляд інформації про ділянку;
	– перегляд інформації про звіти, закріплені до даного замовлення;
	– перегляд інформації про оплату послуг та кількість закріплених охоронців до замовлення.
	Для охоронця має бути реалізований наступний функціонал:
	– реєстрація та аутентифікація з авторизацією у системі;
	– перегляд інформації про доступні замовлення;
	– можливість зарахування до існуючого замовлення та перегляд інформації про замовлення із функціоналом відказу;
	– функціонал розрахунку зарплатні за умовами контракту від власника;
	– перегляд доступного інвентарю системи та закріплення його до охоронця;
	– перегляд власного інвентарю та можливість відказу від нього;
	– функціонал написання нових звітів та перегляду старих закріплених до замовлення.
	Для адміністратора має бути реалізований наступний функціонал:
	– вхід до системи та аутентифікація;
	– керування даними про ділянки власників;
	– керування даними про замовлення власників;
	– перегляд даних про звіти у всіх замовленнях у системі;
	– перегляд існуючого інвентарю, функціонал видалення, редагування та додавання нового інвентарю.
	Також програмна система повинна відповідати архітектурі, мати функціонал експорту даних у різних форматах, збереження бази даних у вигляді резервної копії для подальшого використання у випадку аварійних ситуацій.
 
3 ПРОЕКТУВАННЯ БАЗИ ДАНИХ
	3.1 Побудова ER-діаграми


	Аналізуючи предметну область, було визначено основні сутності та об’єкти, які зараховані до системи, та зв’язки між ними. Для детального перегляду їх було представлено у вигляді ER-діаграми (див. рис. 3.1).
 
Рисунок 3.1 – ER-діаграма бази даних

	У базі даних наявні наступні зв’язки між сутностями:
− ролі і користувачі мають зв’язок один до багатьох бо до однієї ролі може належати багато користувачів;
− користувачі і території мають зв’язок нуль або один бо до одного користувача може належати одна ділянка, а може і ні;
− користувачі і охоронні розширення мають зв’язок нуль або один бо користувач може бути охоронцем, або не бути;
− взятий інвентар і охоронні розширення мають зв’язок один до багатьох бо один охоронець може узяти багато інвентарю одночасно, а може і не узяти;
− взятий інвентар і інвентар мають зв’язок один до багатьох бо інвентар можуть взяти багато, або можуть зовсім не брати;
− охоронні розширення і ранги мають зв’язок один до багатьох бо користувач може мати один ранг, але ранг може належати до багатьох користувачів;
− охоронні розширення і закріплені охоронці до замовлення мають зв’язок нуль або один до одного бо охоронець може бути закріплений лише за одною ділянкою, або зовсім не бути закріпленим;
− закріплені охоронці до замовлення і замовлення мають зв’язок один до багатьох бо до замовлення можуть бути залічені багато охоронців;
− замовлення і звіти охоронця мають зв’язок від нуля до багатьох бо до замовлення може належати багато звітів про патруль;
− звіти охоронця і охоронні розширення мають зв’язок від нуля до багатьох бо від охоронця може бути багато звітів, або не бути зовсім;


	3.2 Побудова логічної моделі бази даних на основі ER-діаграми


Щоб забезпечити форму нормалізації даних необхідно уникнути зв’язку «багато-до-багатьох» між сутностями Users та Ranks, GuardReports, Equipment. Створимо проміжну таблицю яка буде представляти сутність GuardExtentions.
Отже, у логічній структурній моделі бази даних будуть існувати такі сутності:
− користувачі (Users);
− ролі (Roles);
− території (Territories);
− розширення охоронця (GuardExtentions);
− взяття інвентарю (EquipmentClaims);
− інвентар (Equipment);
− ранги (Ranks);
− звіти охоронця (GuardReports);
− охоронець до замовлення (OrderGuards);
− замовлення (Orders);
Створимо таблицю користувачів (Users). Ця таблиця буде містити у собі атрибути: Id (первинний ключ), UserNickname, UserSurname, UserName, Email. PhoneNumber, PasswordHash.
Створимо таблицю ролей (Roles). Ця таблиця буде містити у собі такі атрибути: Id (первинний ключ), Name.
Створимо таблицю територій (Territories). Ця таблиця буде містити у собі атрибути: Id (первинний ключ), OwnerId (зовнішній ключ із зв’язком «нуль або один»), Name, Square, Description, Type.
Створимо таблицю розширень охоронця (GuardExtentions). Ця таблиця буде містити у собі атрибути: Id (первинний ключ), UserId (зовнішній ключ із зв’язком «нуль або один»), RankId (зовнішній ключ із зв’язком «один до багатьох»).
Створимо таблицю взяття інвентарю (EquipmentClaims). Ця таблиця буде містити у собі атрибути: Id (первинний ключ), GuardExtentionsId (зовнішній ключ із зв’язком «нуль або багато»), EquipmentId (зовнішній ключ із зв’язком «один до багатьох»).
Створимо таблицю інвентар (Equipment). Ця таблиця буде містити у собі атрибути: Id (первинний ключ), Name, Type, Amount
Створимо таблицю рангів (Ranks). Ця таблиця буде містити у собі атрибути: Id (первинний ключ), Name, PayPerHour, Description.
Створимо таблицю замовлень охоронців (OrderGuards). Ця таблиця буде містити у собі атрибути: Id (первинний ключ), OrderId (зовнішній ключ «один до багатьох»), GuardExtentionsId (зовнішній ключ із зв’язком «один до багатьох»).
Створимо таблицю замовлень (Orders). Ця таблиця буде містити у собі атрибути: Id (первинний ключ), OwnerId (зовнішній ключ із зв’язком «нуль або один»), TypeOfService, SecurityLevel.
Створимо таблицю звітів охоронців (GuardReports). Ця таблиця буде містити у собі атрибути: Id (первинний ключ), GuardExtentionsId (зовнішній ключ «один до багатьох»), OrderId (зовнішній ключ «один до багатьох»), Date, Message, Descriptions.
Усі таблиці відповідають трьом формам нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.

 
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
	4.1 Архітектура серверної частини


	Користувачами розробленої системи є 3 типи акторів: клієнт, працівник та адміністратор.
Основними потребами клієнта є: можливість додавання своєї ділянки для охорони, перегляд даних про свою ділянку, перегляд залічених працівників до цієї ділянки, статус охорони на ділянці, можливість перегляду звітів із патрулем.
Основними потребами адміністратора є: перегляд даних про клієнта, перегляд даних про працівника, перегляд даних про ділянки у системі, перегляд даних про інвентар працівників та на складі, перегляд розрахованої загальної зарплатні працівникам.
Основними  потребами працівника є: перегляд інвентаря, який можливо буде закріпити, перегляд ділянки до якого закріплено працівника, перегляд даних про власника для контакту, перегляд звітів про патруль, формування звітів із повідомленням.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.1).
Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.
 
Рисунок 4.1 - Діаграма прецедентів серверної частини програмної системи

	Для написання серверної частини системи було обрано мову програмування C# з використанням технології ASP.NET Core, яка забезпечує швидку розробку, високу продуктивність та надійність.
У якості бази даних використано Microsoft SQL Server, до якої з серверного застосунку здійснюється доступ за допомогою технології Entity Framework Core, що надає зручний інтерфейс для взаємодії з базами даних у вигляді об’єктів сутностей.
Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).
 
Рисунок 4.2 – Діаграма розгортання серверної частини програмної системи

	Для демонстрації та тестування API використовується OpenApi (Postman), що дозволяє зручно тестувати та документувати API, покращуючи якість та зручність розробки. Для забезпечення безпеки даних та конфіденційності використовується захищений протокол HTTPS, що захищає дані під час їхньої передачі.
Для реалізації автентифікації та авторизації використано бібліотеку .NET Identity, що забезпечує гнучкий та потужний механізм для управління користувачами та їхнім доступом до різних частин системи. 
Для маршрутизації запитів використанні API контролери, що є вбудованими засобами розробки на ASP .NET Core. Вони дозволяють розділити програму на логічні компоненти, кожен з яких відповідає за обробку конкретного виду запитів або дій користувача. Це спрощує керування кодом та його розширення. 
Розроблений серверний застосунок побудований за принципами Clean Architecture запропонований Microsoft та складається з декількох шарів: User Interface рівень, Domain рівень Infrastructure рівень. У кожному шарі є свої залежності між шарами (див. рис. 4.3).
 
Рисунок 4.3 - Демонстраційна схема архітектури розроблюваного продукту

	У якості способів організації програмного коду було обрано багато шаблонів проектування. Один із обраних був Repository шаблон який дозволяє розподілити зв’язок між базою даних і додатком. Ціль шаблону забезпечити простоту у випадку змінення бази даних або інших веб сервісів. Також усі об’єкти було розбито за допомогою шаблону Data Transfer Object (DTO). Ціль цього шаблону полягає у розподіленні об’єкта на компоненти за якими ми можемо мати одну модель об’єкта системи, та два об’єкта роботи із базою даних де останні роблять відгук до успішності операції. Також було обрано архітектурний шаблон Model-View-Controller (MVC). Задача цього шаблону полягає у розподіленні на шари між об’єктом, з яким йдуть операції, представленням, яке відображує дані, та контролером, який працює із іншими компонентами.
Для того щоб конкретно бачити відгуки програми під час роботи, було використано систему запису звітів зі станом Serilog. Задача цього рішення полягає у докладному розписі звітів про роботу програми під час роботи, наприклад, на сервері, де вже неможливо з тієї машини прямо дивитися дані. 
Архітектура серверного застосунка представлена на діаграмі пакетів (див. рис. 4.4).
 
Рисунок 4.4 - Діаграма пакетів серверної частини програмної системи

	Таким чином, було визначено технології й архітектуру серверної частини програмної системи.


	4.2 Архітектура IoT частини


Користувачами IoT частини розробленої системи є один тип актора: працівник охоронець.
	Основними можливостями користувача є: можливість отримання інформації про одне з замовлень, отримання інформації про звіти на ділянці, відправка звіту із стандартним переліком даних.
	Взаємодію ролі цього типу користувача використовуючи IoT частину систему представлено на діаграмі прецедентів (див. рис. 4.5).
 
Рисунок 4.5 – Діаграма прецедентів IoT частини програмної системи

	Демонстраційна програма можливостей розумного пристрою системи організації працівників приватного охоронного підприємства створена на мові програмування C++. Програмна реалізація максимально наближена до пристроїв RaspberryPi, які можуть запускати програми написані на C++. Причини цього вибору:
	- C++ є мовою компільованою, що дозволяє отримувати швидкий та оптимізований машинний код, який ефективно виконується на ресурсно-обмежених пристроях;
	- C++ має великий набір інструментів для розробки, налагодження та тестування програм, що полегшує процес створення надійного програмного забезпечення для IoT пристроїв.
	У додатку забезпечено відправка даних з серверу за допомогою JSON використовуючи зовнішню бібліотеку nlohmann json.
	Додаток було структуровано на модулях, які відповідають за певну функціональність у системи:
	− WriteCallBack.cpp – модуль в якому реалізовано метод для обробки даних, які отримуються за допомогою бібліотеки libcurl(HTTP запиту);
	− PerformGetRequest.cpp – модуль в якому реалізовано метод для отримання даних серверу за кінцевою точкою для подальшої обробки у системі;
	− PerformPostRequest.cpp – модуль в якому реалізовано метод для відправки даних до серверу за кінцевою точкою для збереження даних у базі даних;
	− GetGuardReports.cpp – модуль в якому реалізовано метод для отримання звітів замовлення для подальшої демонстрації користувачу та аналізу отриманих даних;
	− PerformGetRequestOrderIds.cpp – модуль в якому реалізовано метод для отримання ідентифікаторів усіх замовлень до якого закріплено конкретного охоронця для подальшого отримання звітів та відправки звітів;
	− GetCurrentDateAsJsonString.cpp – модуль в якому реалізовано метод для отримання дати на теперішній час з конвертацією її у формат який сприймає JSON. 
	Для написання програмного застосунку IoT пристрою було обрано мову програмування C++. Основними причинами цього вибору є поширеність зовнішніх бібліотек, контролювання пам'яттю та можливість запуску її на IoT пристрої.
	Для створення HTTPS запитів та зв’язку із сервером було використано бібліотеку curl із vcpkg.
	Для отримання та відправки даних у форматі JSON було використано зовнішню бібліотеку nlohmann json із vcpkg.
	Для отримання даних системи для подальшого використання у системі було використано appSettings.json.
	Сама програма складається із _ складових.
	Для більш детальної візуалізації архітектури розроблюваного додатку та технологій, які були використані у системи, було створено діаграму пакетів (див. рис. 4.7).
 
Рисунок 4.7 – Діаграма пакетів IoT частини програмної системи
Щоб продемонструвати взаємодію додатку із сервером також було створено діаграму взаємодії (див. рис. 4.8) і діаграму діяльності (див. рис. 4.9).
 
Рисунок 4.8 - Діаграма взаємодії IoT частини системи «Secure and Observe»

 
Рисунок 4.9 - Діаграма діяльності

	Діаграма діяльності, що зображена на рисунку, представляє робочий процес розумного пристрою.
	Початковий крок:
	− пристрій отримає дані про охоронця з налаштування системи для подальшої роботи програми.
	Основний потік:
	− прикріплення даних до пристрою – дані охоронця прикріплюються до даних системи для подальшого використання без можливості аутентифікації;
	− перевірка наявності замовлень – програма перевіряє наявність замовлень у охоронця, якщо їх нема то завершуємо роботу, якщо є, навпаки, продовжуємо;
	− отримання даних про замовлення – отримання усієї інформації щодо замовлень прикріплених до охоронця;
	− перегляд опцій користувача – програма надає можливість вибору користувачу щодо наступних дій;
	− отримати звіти - програма надає інформацію про звіти у системі для подальшого перегляду і аналізу;
	− написати новий звіт – програма надає можливість створення нового звіту із описом та повідомленням;
	− отримати статистику – програма надає можливість перегляду обробки отриманих звітів за відсотком кожного у системі за типом;


	4.3 Архітектура клієнтської частини


	Користувачами клієнтської частини розробленої системи є 3 типи акторів: адміністратор, власник закладу та охоронець.
	Основними можливостями власника закладу є: перегляд власної ділянки, перегляд власник замовлень, створення своїх замовлень, перегляд звітів від охоронців, можливість перегляду розрахованої плати працівникам, можливість редагування інформації про замовлення чи видалення, можливість видалення ділянки із системи.
	Основними можливостями охоронцю є: перегляд замовлень до яких закріплено, перегляд доступних замовлень, перегляд інформації про замовлення, перегляд звітів до замовлення, створення звіту до замовлення, перегляд власного інвентарю, перегляд доступного інвентарю, закріплення інвентарю до себе.
	Основними можливостями адміністратору є: перегляд рангів у системи, редагування даних рангу, перегляд ділянок у системи, редагування ділянок у системі, перегляд замовлень у системі, видалення замовлень, редагування замовлень, перегляд звітів у системі, видалення звітів.
Для написання клієнтської частини було обрано мову програмування C# із використанням HTML CSS, що забезпечую швидку розробку і зручність за рахунок статичної типізації.
	Для експортування даних сайту до PDF формату було використано бібліотеку Rotativa для ASP.NET Core додатків, яка надає готові інструменти для створення простих документів.
	Для реалізації перегляду логів системи було використано бібліотеку Serilog із Serilog.Sinks.Seq. Ця бібліотека дозволяє переглядати логи системи використовуючи зручний та ефективний інтерфейс для перегляду інформації.
	Для реалізації перевірки даних користувача було використано бібліотеку jQuery. Ця бібліотека дозволяє зробити перевірку даних лише не клієнтській частині не використовуючи сервер зовсім.
	Для візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.10).
 
Рисунок 4.10 - Діаграма пакетів для клієнтської частини системи “Secure and Observe”
Розроблено клієнтську частину за допомогою трьохшарової архітектури Client-Server. Її відмінність полягає у розділенні додатку на три незалежні шари: презентаційний шар, логічний шар та шар доступу до даних. Презентаційний шар відповідає за взаємодію з користувачем і відображення даних. Логічний шар містить бізнес-логіку додатку і забезпечує обробку даних. Шар доступу до даних відповідає за збереження і отримання даних з бази даних. Структура цієї архітектури нагадує багатошаровий підхід, де кожен шар виконує свої специфічні функції. Цей підхід забезпечує чітке розділення обов'язків та спрощує підтримку і масштабування додатку. Клієнтську частину можна розбити на такі компоненти: Views, Entities, DTO, Controllers, DbContext. 
− Компонент Views зберігає всі представлення, які відображають інформацію користувачу.
− Компоненти Entities та DTO зберігають моделі об’єктів для використання їх з базою даних.
− Компонент Controllers містить всі контролери, які обробляють запити від користувача та координують роботу між презентаційним шаром і логічним шаром.
− Компонент DbContext забезпечує взаємодію з базою даних.
Таким чином, трьохшарова архітектура Client-Server забезпечує організовану та ефективну структуру додатку, розділяючи різні аспекти його функціонування на окремі, чітко визначені шари.
	Для більш детальної візуалізації архітектури системи було розроблено діаграму компонентів (див. рис. 4.11).
 
Рисунок 4.11 – Діаграма компонентів

	Взаємодія користувача із клієнтською частиною починається із введення даних профілю при реєстрації чи авторизації до системи. Під час реєстрації програма перевіряє введені дані і додає їх до системи. Під час авторизації програма перевіряє вхідні дані включаючи роль користувача і в залежності від ролі переходить до панелі адміністратора, сторінки власника, сторінки охоронця.
	Охоронець має можливість переглядати свої ділянки, до якого закріплений. Він може подивитись дані про ділянку, написати новий звіт, переглянути звіти чи відмовитись від замовлення до цієї ділянки. Охоронець має можливість мати свій інвентар, переходячи до сторінки його власного інвентарю він може переглянути увесь закріплений до нього інвентар та за бажанням відкріпити його. На сторінці усього інвентарю у системі він може переглянути увесь інвентар системи та закріпити його до себе за бажанням.
	Власник ділянки може переглядати свої ділянки та замовлення. Також він має можливість переглянути подробиці щодо замовлення чи ділянки. Є можливість перегляду звітів від охоронців. Реалізовано функціонал редагування, видалення даних.
	Адміністратор має функціонал усіх ролей. Він може переглядати ділянки, видаляти та редагувати. Адміністратор може переглядати замовлення, редагувати і видаляти. Адміністратор може переглядати звіти і видаляти їх. 
	Для більш детального представлення взаємодії користувачів було візуалізовано діаграму взаємодії (див. рис. 4.12).
 
Рисунок 4.12 – Діаграма взаємодії
	Таким чином, за допомогою діаграм пакетів, компонентів та взаємодії було визначено основні технології та архітектуру системи.

 
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
	5.1 Виклик і завантаження


	Щоб призвести до роботи програму необхідно завантажити архів, де його розташовано, розархівувати. Так як у програмному застосунку використовується база даних із унікальним з’єднанням, слід зазначити способи її підключення.
	Щоб забезпечити з’єднання програмної системи із базою даних, слід відкрити файл appsettings.json у директорії проекту SecureAndObserve.UI та за допомогою будь-якого редактора змінити вміст потрібного рядка (див. рис. 5.1).
 
Рисунок 5.1 – Рядок підключення до бази даних

	Для того щоб запустити клієнтську частину додатку слід відкрити файл рішення із розширенням .sln та перейти до середи розробки Visual Studio. У панелі інструментів необхідно натиснути на відповідну кнопку для старту додатку.
	 Для того щоб запустити IoT частину проекту слід відкрити  файл із розширенням sln у директорії SecureAndObserve.IoT та перейти до середи розробки Visual Studio. У панелі інструментів необхідно натиснути на відповідну кнопку для старту додатку.


	5.2 Призначення і логічна структура


	Функціонал, який підтримує програма, можна розбити на модулі, а саме:
	− авторизація та реєстрація;
	− ділянки;
	− замовлення;
	− інвентар;
	− користувачі системи за ролями;
	− звіти охоронця;
	− логування.
	Модуль «Авторизація та реєстрація» містить у собі функціонал авторизації та реєстрації користувача у системі. У програмній системі реалізовано три ролі користувачів. Щоб перейти до адмін панелі системи, слід ввести ім’я користувача admin та пароль 12345a.
	Модуль «Ділянки» містить у собі функціонал роботи із ділянками. Користувач власник має можливість додавати, редагувати, видаляти та переглядати ділянки у системі за його даними.
	Модуль «Замовлення» містить у собі функціонал роботи із замовленням. Користувач за ролями охоронця чи власника має можливість переглядати інформацію про ділянку. Власник може редагувати та додавати нове замовлення.
	Модуль «Інвентар» містить у собі функціонал роботи із інвентарем. Користувач за роллю адміністратор може додавати новий інвентар до системи, редагувати та видаляти. Охоронець може переглядати і закріплювати за собою певний інвентар.
	Модуль «Користувачі системи за ролями» містить у собі певний функціонал роботи із програмою за окремою роллю.
	Модуль «Звіти охоронця» містить у собі функціонал роботи із звітами. Охоронець може переглядати і додавати новий звіт до замовлення. Власник може переглядати написані звіти охоронцями.
	Модуль «Логування» містить у собі функціонал перегляду логів системи за допомогою даних адміністратора.


	5.3 Опис програмної реалізації


	При запуску програми можна побачити сторінку авторизації за даними користувача з можливістю переходу до вікна реєстрації (див. рис. 5.2 – 5.3).
 
Рисунок 5.2 – Вікно авторизації до системи
 
Рисунок 5.3 – Вікно реєстрації

Після входу до системи як власник, нас зустрічає вікно перегляду ділянок та замовлень (див. рис. 5.4).  
Рисунок 5.4 – Вікно перегляду ділянок та мовлень від власника

Користувач власник має можливість додавання ділянки (див. рис. 5.5).
 
Рисунок 5.5 – Вікно додавання нової ділянки
Користувач власник має можливість додавання замовлення (див. рис. 5.6). Рисунок 5.6 – Вікно із додаванням замовлення

	Власник має можливість переглядати інформації про замовлення (див. рис. 5.7).
 
Рисунок 5.7 – Вікно із переглядом інформації
	Входячи у систему як охоронець, нас зустрічає панель перегляду закріплених замовлень до охоронця (див. рис. 5.8).
 
Рисунок 5.8 – Панель закріплених ділянок

	Охоронець має можливість приєднатися до конкретного замовлення (див. рис. 5.9).
 
Рисунок 5.9 – Закріплення охоронця до замовлення

	Користувач охоронець має можливість додавання нового звіту до замовлення (див. рис. 5.10).
 
Рисунок 5.10 – Вікно додавання нового звіту до замовлення

	Користувач охоронець має можливість перегляду закріпленого до нього інвентарю (див. рис. 5.11).
 
Рисунок 5.11 – Вікно перегляду закріпленого інвентарю
	Користувач має можливість переглядати наявний інвентар, закріпляти його та відпкріпляти (див. рис. 5.12).
 
Рисунок 5.12 – Вікно перегляду усього інвентарю у системі.

	Користувач адміністратор має можливість редагування усіх даних та зв’язків, включаючи редагування інформації про ранги охоронців.
 
Рисунок 5.13 – Вікно перегляду інформації про ранги із можливістю редагування.

	Адміністратор має можливість переглядання логів у системі (див. рис. 5.14)
 
Рисунок 5.14 – Перегляд логів системи
 
ВИСНОВКИ


	Результатами виконання роботи були розробка програмної системи для організації роботи працівників приватного охоронного підприємства.
	Протягом роботи було проаналізовано предметну область, створено та спроектовано базу даних, використано розповсюджену архітектуру для серверної та клієнтської частини із допомогою ASP.NET Core використовуючи мову програмування C# та C++ для написання програмної частини IoT додатку.
	Розроблена програмна система дозволяє власникам бізнесів зручно створювати, переглядати інформацію про свою ділянку та дивитися звіти від охоронців із діями, підраховувати зарплатню. Охоронці можуть зручно переглядати усі бізнеси, дивитися інформацію про замовлення із зарплатнею, переглядати увесь наявний інвентар та закріплювати за собою необхідний.
	
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


	1. Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series) / R. Helm та ін. Addison-Wesley Professional, 1995. 395 р.
	2. ASP.NET Documentation. URL: https://learn.microsoft.com/ru-ru/aspnet/overview (дата звернення 20.05.2024).
	3. Serilog documentation. URL: https://serilog.net/ (дата звернення 20.05.2024).
	4. Refactoring Guru. Design patterns. URL: https://refactoring.guru/design-patterns (дата звернення 15.05.2024).
	5. C# Documentation. URL: https://learn.microsoft.com/ru-ru/dotnet/csharp/ (дата звернення 01.05.2024).
	6. EF Core Documentation. URL: https://learn.microsoft.com/ru-ru/ef/core/ (дата звернення 20.05.2024).
 
ДОДАТОК А
Програмний код серверної частини
	А.1 Код основного файлу для роботи серверу Program.cs:


1 using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
2 using Microsoft.AspNetCore.Identity;
3 using Microsoft.EntityFrameworkCore;
4 using SecureAndObserve.Core.Domain.IdentityEntities;
5 using SecureAndObserve.Infrastructure.DbContext;
6 using Serilog;
7 using Microsoft.AspNetCore.Authorization;
8 using SecureAndObserve.Core.ServiceContracts;
9 using SecureAndObserve.Core.Services;
10 using SecureAndObserve.Core.Domain.RepositoryContracts;
11 using SecureAndObserve.Infrastructure.Repositories;
12 using Microsoft.AspNetCore.Mvc.Razor;
13 using Microsoft.AspNetCore.Localization;
14 using System.Globalization;
15 using Microsoft.Extensions.Localization;
16 
17 var builder = WebApplication.CreateBuilder(args);
18 
19 builder.Host.UseSerilog((HostBuilderContext context, IServiceProvider services, LoggerConfiguration loggerConfiguration) => {
20 
21     loggerConfiguration
22     .ReadFrom.Configuration(context.Configuration)
23     .ReadFrom.Services(services);
24 });
25 
26 builder.Services.AddControllersWithViews();
27 /*            .AddViewLocalization(LanguageViewLocationExpanderFormat.Suffix)
28             .AddDataAnnotationsLocalization();
29 builder.Services.AddLocalization(options => options.ResourcesPath = "Resources");
30 
31 builder.Services.Configure<RequestLocalizationOptions>(options =>
32 {
33     List<CultureInfo> supportedCultures = new List<CultureInfo>();
34     supportedCultures.Add(new CultureInfo("en-US"));
35     supportedCultures.Add(new CultureInfo("ua-UA"));
36     options.DefaultRequestCulture = new RequestCulture("ua-UA");
37     options.SupportedCultures = supportedCultures;
38     options.SupportedUICultures = supportedCultures;
39 });
40 builder.Services.AddScoped<IStringLocalizer>();*/
41 
42 builder.Services.AddDbContext<ApplicationDbContext>(options =>
43 {
44     options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
45 });
46 
47 
48 builder.Services.AddScoped<IOrdersRepository, OrdersRepository>();
49 builder.Services.AddScoped<IGuardExstensionsRepository, GuardExstensionsRepository>();
50 builder.Services.AddScoped<IRanksRepository, RanksRepository>();
51 builder.Services.AddScoped<ITerritoriesRepository, TerritoriesRepository>();
52 builder.Services.AddScoped<IOrderGuardsRepository, OrderGuardsRepository>();
53 builder.Services.AddScoped<IGuardReportRepository, GuardReportRepository>();
54 builder.Services.AddScoped<IEquipmentRepository, EquipmentRepository>();
55 builder.Services.AddScoped<IEquipmentClaimsRepository, EquipmentClaimsRepository>();
56 
57 
58 builder.Services.AddScoped<IOrdersService, OrdersService>();
59 builder.Services.AddScoped<IGuardExstensionsService, GuardExstensionsService>();
60 builder.Services.AddScoped<IRanksService, RanksService>();
61 builder.Services.AddScoped<ITerritoriesService, TerritoriesService>();
62 builder.Services.AddScoped<IOrderGuardsService, OrderGuardsService>();
63 builder.Services.AddScoped<IGuardReportsService, GuardReportsService>();
64 builder.Services.AddScoped<IEquipmentService, EquipmentService>();
65 builder.Services.AddScoped<IEquipmentClaimsService, EquipmentClaimsService>();
66 
67 
68 builder.Services.AddIdentity<ApplicationUser, ApplicationRole>((options) =>
69 {
70     options.Password.RequiredLength = 5;
71     options.Password.RequireNonAlphanumeric = false;
72     options.Password.RequireUppercase = false;
73     options.Password.RequireLowercase = true;
74     options.Password.RequireDigit = false;
75     options.Password.RequiredUniqueChars = 3;
76 })
77     .AddEntityFrameworkStores<ApplicationDbContext>()
78     .AddDefaultTokenProviders()
79     .AddUserStore<UserStore<ApplicationUser, ApplicationRole, ApplicationDbContext, Guid>>()
80     .AddRoleStore<RoleStore<ApplicationRole, ApplicationDbContext, Guid>>();
81 
82 
83 builder.Services.AddAuthorization(options =>
84 {
85     options.FallbackPolicy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();
86 });
87 builder.Services.ConfigureApplicationCookie(options =>
88 {
89     options.LoginPath = "/Home/Login";
90 });
91 
92 builder.Services.AddHttpLogging(options =>
93 {
94     options.LoggingFields = Microsoft.AspNetCore.HttpLogging.HttpLoggingFields.RequestProperties | Microsoft.AspNetCore.HttpLogging.HttpLoggingFields.ResponsePropertiesAndHeaders;
95 });
96 
97 
98 var app = builder.Build();
99 
100 
101 if (builder.Environment.IsDevelopment())
102 {
103     app.UseDeveloperExceptionPage();
104 }
105 app.UseHsts();
106 app.UseHttpsRedirection();
107 app.UseSerilogRequestLogging();
108 
109 app.UseHttpLogging();
110 
111 if (builder.Environment.IsEnvironment("Test") == false)
112     Rotativa.AspNetCore.RotativaConfiguration.Setup("wwwroot", wkhtmltopdfRelativePath: "Rotativa");
113 
114 app.UseStaticFiles();
115 
116 /*List<CultureInfo> supportedCultures = new List<CultureInfo>();
117 supportedCultures.Add(new CultureInfo("en-US"));
118 supportedCultures.Add(new CultureInfo("ua-UA"));
119 var localizationOptions = new RequestLocalizationOptions
120 {
121     DefaultRequestCulture = new RequestCulture("ua-UA"),
122     SupportedCultures = supportedCultures,
123     SupportedUICultures = supportedCultures
124 };
125 
126 app.UseRequestLocalization(localizationOptions);*/
127 
128 app.UseRouting();
129 app.UseAuthentication();
130 app.UseAuthorization();
131 app.MapControllers();
132 
133 
134 app.UseEndpoints(endpoints =>
135 {
136     endpoints.MapControllerRoute(
137         name: "areas",
138         pattern: "{area:exists}/{controller=Home}/{action=Index}");
139 
140     endpoints.MapControllerRoute(
141         name: "default",
142         pattern: "{controller}/{action}/{id?}");
143 });
144 
145 
146 app.Run();
147 
148 public partial class Program { }

	А.2 Код сервісного класу для роботи із даними охоронця:

1 using SecureAndObserve.Core.Domain.Entities;
2 using SecureAndObserve.Core.Domain.RepositoryContracts;
3 using SecureAndObserve.Core.DTO;
4 using SecureAndObserve.Core.ServiceContracts;
5 using System;
6 using System.Collections.Generic;
7 using System.Linq;
8 using System.Text;
9 using System.Threading.Tasks;
10 
11 namespace SecureAndObserve.Core.Services
12 {
13     public class GuardExstensionsService : IGuardExstensionsService
14     {
15         private readonly IGuardExstensionsRepository _guardExstensionsRepository;
16         public GuardExstensionsService(IGuardExstensionsRepository guardExstensionsRepository) {
17             _guardExstensionsRepository = guardExstensionsRepository;
18         }
19         public async Task<GuardExstensionsResponse> AddGuardExstensions(GuardExstensionsAddRequest? guardExstensionsAddRequest)
20         {
21             if (guardExstensionsAddRequest == null)
22                 throw new ArgumentNullException(nameof(guardExstensionsAddRequest));
23             if (guardExstensionsAddRequest.UserId == null)
24                 throw new ArgumentException(nameof(guardExstensionsAddRequest.UserId));
25             GuardExstensions guardExstensions = guardExstensionsAddRequest.ToGuardExstensions();
26             guardExstensions.Id = Guid.NewGuid();
27             await _guardExstensionsRepository.AddGuardExstensions(guardExstensions);
28             return guardExstensions.ToGuardExstensionsResponse();
29         }
30         public async Task<List<GuardExstensionsResponse>> GetAllGuardExstensions()
31         {
32             List<GuardExstensions> guardExstensions = await _guardExstensionsRepository.GetAllGuardExstensions();
33             return guardExstensions.Select(guardExstension => guardExstension.ToGuardExstensionsResponse()).ToList();
34         }
35 
36         public async Task<GuardExstensionsResponse?> GetGuardsExstensionsByGuardExstensionsId(Guid? guardExstensionsId)
37         {
38             if (guardExstensionsId == null)
39                 return null;
40             GuardExstensions? guardExstensions = await _guardExstensionsRepository.GetGuardExstensionyByGuardExstensionId(guardExstensionsId.Value);
41             if (guardExstensions == null)
42                 return null;
43             return guardExstensions.ToGuardExstensionsResponse();
44         }
45     }
46 }

	А.3 Код контролеру із роботою API та даними користувача

	1 using Microsoft.AspNetCore.Authorization;
2 using Microsoft.AspNetCore.Http;
3 using Microsoft.AspNetCore.Mvc;
4 using Microsoft.EntityFrameworkCore;
5 using SecureAndObserve.Core.Domain.Entities;
6 using SecureAndObserve.Infrastructure.DbContext;
7 
8 namespace SecureAndObserve.UI.Controllers
9 {
10     [Route("api/[controller]")]
11     [AllowAnonymous]
12     [ApiController]
13     public class GuardExstensionsApiController : ControllerBase
14     {
15         private readonly ApplicationDbContext _context;
16 
17         public GuardExstensionsApiController(ApplicationDbContext context)
18         {
19             _context = context;
20         }
21         [HttpGet]
22         public async Task<ActionResult<IEnumerable<GuardExstensions>>> GetGuardExstensions()
23         {
24             if (_context.GuardExstensions == null)
25             {
26                 return NotFound();
27             }
28             return await _context.GuardExstensions.ToListAsync();
29         }
30         [HttpGet("{id}")]
31         public async Task<ActionResult<GuardExstensions>> GetGuardExstensions(Guid id)
32         {
33             if (_context.GuardExstensions == null)
34             {
35                 return NotFound();
36             }
37             var guard = await _context.GuardExstensions.FindAsync(id);
38 
39             if (guard == null)
40             {
41                 return NotFound();
42             }
43 
44             return guard;
45         }
46 
47         [HttpPost]
48         public async Task<ActionResult<GuardExstensions>> PostGuardExstentions(GuardExstensions guardExstensions)
49         {
50             if (_context.GuardExstensions == null)
51             {
52                 return Problem("Entity set 'ApplicationDbContext.GuardExtensions'  is null.");
53             }
54             await _context.GuardExstensions.AddAsync(guardExstensions);
55             await _context.SaveChangesAsync();
56 
57             return CreatedAtAction("Get GuardExtensions", new { id = guardExstensions.Id }, guardExstensions);
58         }
59 
60         [HttpDelete("{id}")]
61         public async Task<IActionResult> DeleteGuardExstension(Guid id)
62         {
63             if (_context.GuardExstensions == null)
64             {
65                 return NotFound();
66             }
67             var guardExstensions = await _context.GuardExstensions.FindAsync(id);
68             if (guardExstensions == null)
69             {
70                 return NotFound();
71             }
72 
73             _context.GuardExstensions.Remove(guardExstensions);
74             await _context.SaveChangesAsync();
75 
76             return NoContent();
77         }
78 
79         private bool UserExists(Guid id)
80         {
81             return (_context.GuardReports?.Any(e => e.Id == id)).GetValueOrDefault();
82         }
83     }
84 }
85 

 
ДОДАТОК Б
Програмний код IoT пристрою
Б.1 Код програми IoT пристрою:

Б.1 Код WriteCallBack
1 static size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* s) {
2     size_t newLength = size * nmemb;
3     size_t oldLength = s->size();
4     try {
5         s->resize(oldLength + newLength);
6     }
7     catch (std::bad_alloc& e) {
8         // Handle memory problem
9         return 0;
10     }
11 
12     std::copy((char*)contents, (char*)contents + newLength, s->begin() + oldLength);
13     return newLength;
14 }

Б.2 Код performGetRequest

1 void performGetRequest(const std::string& url, json& getData) {
2     CURL* curl;
3     CURLcode res;
4     std::string readBuffer;
5 
6     curl = curl_easy_init();
7     if (curl) {
8         curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
9         curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
10         curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
11 
12         res = curl_easy_perform(curl);
13         if (res != CURLE_OK) {
14             std::cerr << "GET request failed: " << curl_easy_strerror(res) << std::endl;
15         }
16         else {
17             try {
18                 getData = json::parse(readBuffer);
19                 std::cout << "Get data success!\n" << std::endl;
20             }
21             catch (json::parse_error& e) {
22                 std::cerr << "JSON parse error: " << e.what() << std::endl;
23             }
24         }
25 
26         curl_easy_cleanup(curl);
27     }
28 }

Б.3 Код performPostRequest

1 void performPostRequest(const std::string& url, const json& jsonData) {
2     CURL* curl;
3     CURLcode res;
4     std::string readBuffer;
5 
6     curl = curl_easy_init();
7     if (curl) {
8         std::string jsonString = jsonData.dump();
9 
10         struct curl_slist* headers = nullptr;
11         headers = curl_slist_append(headers, "Content-Type: application/json");
12 
13         curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
14         curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
15         curl_easy_setopt(curl, CURLOPT_POST, 1L);
16         curl_easy_setopt(curl, CURLOPT_POSTFIELDS, jsonString.c_str());
17         curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
18         curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
19 
20         res = curl_easy_perform(curl);
21         if (res != CURLE_OK) {
22             std::cerr << "POST request failed: " << curl_easy_strerror(res) << std::endl;
23         }
24         else {
25             try {
26                 auto jsonResponse = json::parse(readBuffer);
27                 std::cout << "POST Response JSON:\n" << jsonResponse.dump(4) << std::endl;
28             }
29             catch (json::parse_error& e) {
30                 std::cerr << "JSON parse error: " << e.what() << std::endl;
31             }
32         }
33 
34         curl_slist_free_all(headers);
35         curl_easy_cleanup(curl);
36     }
37 }

Б.4 Код performGetRequestOrderIds

1 void performGetRequestOrderIds(const std::string& url, std::vector<std::string>& orderIds) {
2     CURL* curl;
3     CURLcode res;
4     std::string readBuffer;
5 
6     curl = curl_easy_init();
7     if (curl) {
8         curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
9         curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
10         curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
11 
12         res = curl_easy_perform(curl);
13         if (res != CURLE_OK) {
14             std::cerr << "GET request failed: " << curl_easy_strerror(res) << std::endl;
15         }
16         else {
17             try {
18                 auto jsonResponse = json::parse(readBuffer);
19                 if (jsonResponse.is_array()) {
20                     for (const auto& item : jsonResponse) {
21                         if (item.contains("orderId")) {
22                             orderIds.push_back(item["orderId"]);
23                         }
24                     }
25                 }
26                 else {
27                     std::cerr << "Expected JSON array." << std::endl;
28                 }
29             }
30             catch (json::parse_error& e) {
31                 std::cerr << "JSON parse error: " << e.what() << std::endl;
32             }
33         }
34 
35         curl_easy_cleanup(curl);
36     }
37 }

Б.5 Код ServiceInfo performGetRequest

1 ServiceInfo performGetRequest(const std::string& url) {
2     CURL* curl;
3     CURLcode res;
4     std::string readBuffer;
5 
6     curl = curl_easy_init();
7     if (curl) {
8         curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
9         curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
10         curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
11 
12         res = curl_easy_perform(curl);
13         if (res != CURLE_OK) {
14             std::cerr << "GET request failed: " << curl_easy_strerror(res) << std::endl;
15         }
16         else {
17             try {
18                 auto jsonResponse = json::parse(readBuffer);
19                 for (const auto& item : jsonResponse) {
20                     ServiceInfo info;
21                     if (item.contains("typeOfService")) {
22 
23                         info.typeOfService = item["typeOfService"];
24                     }
25                     if (item.contains("securityLevel"))
26                     {
27                         info.securityLevel = item["securityLevel"];
28                     }
29                     return info;
30                 }
31             }
32             catch (json::parse_error& e) {
33                 std::cerr << "JSON parse error: " << e.what() << std::endl;
34             }
35         }
36 
37         curl_easy_cleanup(curl);
38     }
39     return {};
40 }

Б.6 Код імпорту налаштувань системи

1 std::ifstream inputFile("appSettings.json");
2 if (!inputFile.is_open()) {
3     std::cerr << "Can't open file appSettings.json" << std::endl;
4     return 1;
5 }
6 json settings;
7 inputFile >> settings;
8 std::string serverUrl = settings["serverUrl"];
9 std::cout << "URL: " << serverUrl << std::endl;

Б.7 Код обробки даних

1 string orderId = orders[stoi(choiceOrderNumber) - 1].id;
2 getUrl = serverUrl + "/api/GuardReportsApi/" + orderId;
3 std::vector<GuardReportInfo> reports = getGuardReports(getUrl);
4 double stableCount = 0;
5 double suspiciousCount = 0;
6 double dangerousCount = 0;
7 for (const auto& report : reports) {
8     if (report.Message == "Stable")
9         stableCount++;
10     if (report.Message == "Suspicious")
11         suspiciousCount++;
12     if (report.Message == "Dangerous")
13         dangerousCount++;
14 }
15 cout << "Stable reports: " << stableCount / reports.capacity() * 100 << endl;
16 cout << "Suspicious reports: " << suspiciousCount / reports.capacity() * 100 << endl;
17 cout << "Dangerous reports: " << dangerousCount / reports.capacity() * 100 << endl;
 	
 
ДОДАТОК В
Код клієнтської частини програмного застосунку
	В.1 Код контролеру для роботи із панеллю власника:

	1 using Microsoft.AspNetCore.Mvc;
2 using NuGet.Protocol;
3 using SecureAndObserve.Core.Domain.IdentityEntities;
4 using SecureAndObserve.Core.DTO;
5 using SecureAndObserve.Core.Enums;
6 using SecureAndObserve.Core.ServiceContracts;
7 using System.Globalization;
8 using System.Security.Claims;
9 using System.Security.Principal;
10 using Microsoft.AspNetCore.Mvc;
11 using Microsoft.AspNetCore.Mvc.Rendering;
12 using Rotativa.AspNetCore;
13 using SecureAndObserve.Infrastructure.DbContext;
14 using Microsoft.EntityFrameworkCore;
15 using SecureAndObserve.Core.Domain.Entities;
16 using Microsoft.AspNetCore.Identity;
17 using SecureAndObserve.UI.Controllers;
18 
19 namespace SecureAndObserve.UI.Areas.Owner.Controllers
20 {
21     [Area("Owner")]
22     [Route("[controller]")]
23     public class OwnerController : Controller
24     {
25         private readonly ITerritoriesService _territoriesService;
26         private readonly IOrdersService _ordersService;
27         private readonly IOrderGuardsService _orderGuardsService;
28         private readonly IGuardExstensionsService _guardExstensionsService;
29         private readonly IRanksService _ranksService;
30         private readonly ILogger<OwnerController> _logger;
31         private readonly ApplicationDbContext _context;
32         private readonly SignInManager<ApplicationUser> _signInManager;
33 
34         public OwnerController(ITerritoriesService territoriesService, ILogger<OwnerController> logger, ApplicationDbContext context, SignInManager<ApplicationUser> signInManager, IOrdersService ordersService, IOrderGuardsService orderGuardsService, IGuardExstensionsService guardExstensionsService, IRanksService ranksService)
35         {
36             _territoriesService = territoriesService;
37             _logger = logger;
38             _context = context;
39             _signInManager = signInManager;
40             _ordersService = ordersService;
41             _orderGuardsService = orderGuardsService;
42             _guardExstensionsService = guardExstensionsService;
43             _ranksService = ranksService;
44         }
45 
46         [HttpGet]
47         [Route("Index")]
48         public async Task<IActionResult> Index(string searchBy, string? searchString, string sortBy = nameof(TerritoryResponse.Name), SortOrderOptions sortOrder = SortOrderOptions.ASC)
49         {
50             _logger.LogInformation("Index action method of PersonsController");
51             _logger.LogDebug($"searchBy: {searchBy}, searchString: {searchString}, sortOrder: {sortOrder}");
52             //Search
53             ViewBag.SearchFields = new Dictionary<string, string>()
54             {
55                 { nameof(TerritoryResponse.Name), "Name" },
56                 { nameof(TerritoryResponse.Square), "Square" },
57                 { nameof(TerritoryResponse.Description), "Description" },
58                 { nameof(TerritoryResponse.Type), "Type" },
59             };
60             List<TerritoryResponse> territories = await _territoriesService.GetFilteredTerritories(searchBy, searchString);
61 
62             ViewBag.CurrentSearchBy = searchBy;
63             ViewBag.CurrentSearchString = searchString;
64 
65             //Sort
66             List<TerritoryResponse> sortedTerritories = await _territoriesService.GetSortedTerritories(territories, sortBy, sortOrder);
67 
68             ViewBag.CurrentSortBy = sortBy.ToString();
69             ViewBag.CurrentSortOrder = sortOrder.ToString();
70 
71             //Id of authenticated user
72             var userClaims = User.Identity as ClaimsIdentity;
73             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
74 
75             List<TerritoryResponse> finalTerritories = new List<TerritoryResponse>();
76 
77             foreach (TerritoryResponse territory in sortedTerritories)
78             {
79                 if(Convert.ToString(territory.OwnerId) == userId)
80                     finalTerritories.Add(territory);
81             }
82 
83             List<OrderResponse> orders = await _ordersService.GetAllOrders();
84             List<OrderResponse> finalOrder = new List<OrderResponse>();
85             foreach (OrderResponse order in orders)
86             {
87                 if (Convert.ToString(order.OwnerId) == userId)
88                     finalOrder.Add(order);
89             }
90             ViewBag.Order = finalOrder;
91 
92             return View(finalTerritories);
93         }
94 
95         [HttpGet]
96         [Route("CreateTerritory")]
97         public async Task<IActionResult> CreateTerritory()
98         {
99             return View();
100         }
101 
102         [HttpPost]
103         [Route("CreateTerritory")]
104         public async Task<IActionResult> CreateTerritory(TerritoryAddRequest territoryAddRequest)
105         {
106             if (!ModelState.IsValid)
107             {
108 
109                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
110                 return View(territoryAddRequest);
111             }
112 
113             var userClaims = User.Identity as ClaimsIdentity;
114             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
115 
116             Guid guid = new Guid(userId);
117 
118             territoryAddRequest.OwnerId = guid;
119 
120             //call the service method
121             TerritoryResponse personResponse = await _territoriesService.AddTerritory(territoryAddRequest);
122 
123             //navigate to Index() action method (its makes another get request to "owner/index")
124             return RedirectToAction("Index", "Owner");
125         }
126 
127         [HttpGet]
128         [Route("EditTerritory")]
129         public async Task<IActionResult> EditTerritory(Guid territoryID)
130         {
131             TerritoryResponse? territoryResponse = await _territoriesService.GetTerritoryByTerritoryId(territoryID);
132             if (territoryResponse == null)
133             {
134                 return RedirectToAction("Index");
135             }
136 
137             return View(territoryResponse);
138         }
139 
140         [HttpPost]
141         [Route("EditTerritory")]
142         public async Task<IActionResult> EditTerritory(TerritoryResponse territoryResponse)
143         {
144             if (territoryResponse == null)
145             {
146                 return RedirectToAction("Index");
147             }
148 
149             var territoryInDb = await _context.Territories.FirstOrDefaultAsync(x => x.Id == territoryResponse.Id);
150             if (ModelState.IsValid)
151             {
152                 if (territoryInDb != null)
153                 {
154                     territoryInDb.Name = territoryResponse.Name;
155                     territoryInDb.Square = territoryResponse.Square;
156                     territoryInDb.Description = territoryResponse.Description;
157                     territoryInDb.Type = territoryResponse.Type;
158                     await _context.SaveChangesAsync();
159                     return RedirectToAction("Index", "Owner");
160                 }
161             }
162             else
163             {
164                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
165                 return View(territoryResponse);
166             }
167 
168             return View(territoryResponse);
169         }
170         [HttpGet]
171         [Route("CreateOrder")]
172         public async Task<IActionResult> CreateOrder()
173         {
174             return View();
175         }
176         [HttpPost]
177         [Route("CreateOrder")]
178         public async Task<IActionResult> CreateOrder(OrderAddRequest orderAddRequest)
179         {
180             if (!ModelState.IsValid)
181             {
182 
183                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
184                 return View(orderAddRequest);
185             }
186 
187             var userClaims = User.Identity as ClaimsIdentity;
188             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
189 
190             Guid guid = new Guid(userId);
191 
192             orderAddRequest.OwnerId = guid;
193 
194             //call the service method
195             OrderResponse orderResponse = await _ordersService.AddOrder(orderAddRequest);
196 
197             //navigate to Index() action method (its makes another get request to "owner/index")
198             return RedirectToAction("Index", "Owner");
199         }
200 
201         [HttpGet]
202         [Route("DeleteOrder/{orderID}")]
203         public async Task<IActionResult> DeleteOrder(Guid orderID)
204         {
205             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderID);
206             if (orderResponse == null)
207                 return RedirectToAction("Index");
208             return View(orderResponse);
209         }
210         [HttpPost]
211         [Route("DeleteOrder/{orderID}")]
212         public async Task<IActionResult> DeleteOrder(OrderResponse orderResponseToDelete)
213         {
214             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderResponseToDelete.Id);
215             if (orderResponse == null)
216                 return RedirectToAction("Index");
217 
218             List<OrderGuards> orderGuardsList = await _context.OrderGuards.Where(x => x.OrderId == orderResponseToDelete.Id).ToListAsync();
219 
220             foreach(OrderGuards orderGuards in orderGuardsList)
221             {
222                 await _orderGuardsService.DeleteOrderGuards(orderGuards.Id);
223             }
224 
225             await _ordersService.DeleteOrder(orderResponse.Id);
226             return RedirectToAction("Index");
227         }
228 
229         [HttpGet]
230         [Route("OrderGuards/{orderID}")]
231         public async Task<IActionResult> OrderGuards(Guid orderID)
232         {
233             List<OrderGuards> orderGuardsList = await _context.OrderGuards.Where(x => x.OrderId == orderID).ToListAsync();
234             List<GuardExstensionsResponse> guardExstensionsList = await _guardExstensionsService.GetAllGuardExstensions();
235             List<GuardExstensionsResponse> finalGuardExstensionsList = new List<GuardExstensionsResponse>();
236             foreach(OrderGuards orderGuards in orderGuardsList)
237             {
238                 foreach(GuardExstensionsResponse guardExstensions in guardExstensionsList)
239                 {
240                     if (guardExstensions.Id == orderGuards.GuardExstensionsId)
241                         finalGuardExstensionsList.Add(guardExstensions);
242                 }
243             }
244             List<RankResponse> ranks = await _ranksService.GetAllRanks();
245             List<RankResponse> finalRanks = new List<RankResponse>();
246             foreach(GuardExstensionsResponse guardExstentions in finalGuardExstensionsList)
247             {
248                 foreach(RankResponse rank in ranks)
249                 {
250                     if(guardExstentions.RankId == rank.Id)
251                         finalRanks.Add(rank);
252                 }
253             }
254             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderID);
255             double orientedPayPerHour = 0;
256             foreach (RankResponse rank in finalRanks)
257             {
258                 double payPerHour = rank.PayPerHour;
259                 if (orderResponse.TypeOfService == ServiceTypeOptions.PlacementOnPosts.ToString())
260                     payPerHour = payPerHour * 1.1;
261                 if (orderResponse.TypeOfService == ServiceTypeOptions.Patrol.ToString())
262                     payPerHour = payPerHour * 1.3;
263                 if (orderResponse.TypeOfService == SecurityLevelOptions.Medium.ToString())
264                     payPerHour = payPerHour * 1.3;
265                 if (orderResponse.TypeOfService == SecurityLevelOptions.High.ToString())
266                     payPerHour = payPerHour * 1.5;
267 
268                 orientedPayPerHour += payPerHour;
269             }
270 
271 
272             ViewBag.AmountOfGuards = finalGuardExstensionsList.Count;
273             ViewBag.OrientedPayPerHour = Math.Round(orientedPayPerHour,2).ToString();
274 
275 
276             return View();
277         }
278 
279         public async Task<IActionResult> Logout()
280         {
281             await _signInManager.SignOutAsync();
282             return RedirectToAction(nameof(HomeController.Login), "Home");
283         }
284     }
285 }

	В.2 Код контролеру для роботи із панеллю охоронця

	1 using Microsoft.AspNetCore.Identity;
2 using Microsoft.AspNetCore.Mvc;
3 using Microsoft.EntityFrameworkCore;
4 using SecureAndObserve.Core.Domain.Entities;
5 using SecureAndObserve.Core.Domain.IdentityEntities;
6 using SecureAndObserve.Core.DTO;
7 using SecureAndObserve.Core.Enums;
8 using SecureAndObserve.Core.ServiceContracts;
9 using SecureAndObserve.Infrastructure.DbContext;
10 using SecureAndObserve.UI.Areas.Owner.Controllers;
11 using SecureAndObserve.UI.Controllers;
12 using System.Globalization;
13 using System.Security.Claims;
14 
15 namespace SecureAndObserve.UI.Areas.Guard.Controllers
16 {
17     [Area("Guard")]
18     [Route("[controller]")]
19     public class GuardController : Controller
20     {
21 
22         private readonly ITerritoriesService _territoriesService;
23         private readonly IOrdersService _ordersService;
24         private readonly IGuardExstensionsService _guardExstensionsService;
25         private readonly IOrderGuardsService _orderGuardsService;
26         private readonly IGuardReportsService _guardReportsService;
27         private readonly IEquipmentService _equipmentService;
28         private readonly IEquipmentClaimsService _equipmentClaimsService;
29         private readonly ILogger<GuardController> _logger;
30         private readonly ApplicationDbContext _context;
31         private readonly SignInManager<ApplicationUser> _signInManager;
32 
33         public GuardController(ITerritoriesService territoriesService, ILogger<GuardController> logger, ApplicationDbContext context, SignInManager<ApplicationUser> signInManager, IOrdersService ordersService, IGuardExstensionsService guardExstensionsService, IOrderGuardsService orderGuardsService, IGuardReportsService guardReportsService, IEquipmentService equipmentService, IEquipmentClaimsService equipmentClaimsService)
34         {
35             _territoriesService = territoriesService;
36             _logger = logger;
37             _context = context;
38             _signInManager = signInManager;
39             _ordersService = ordersService;
40             _guardExstensionsService = guardExstensionsService;
41             _orderGuardsService = orderGuardsService;
42             _guardReportsService = guardReportsService;
43             _equipmentService = equipmentService;
44             _equipmentClaimsService = equipmentClaimsService;
45         }
46 
47         [HttpGet]
48         [Route("Index")]
49         public async Task<IActionResult> Index(string searchBy, string? searchString, string sortBy = nameof(TerritoryResponse.Name), SortOrderOptions sortOrder = SortOrderOptions.ASC)
50         {
51             _logger.LogInformation("Index action method of PersonsController");
52             _logger.LogDebug($"searchBy: {searchBy}, searchString: {searchString}, sortOrder: {sortOrder}");
53             //Search
54             ViewBag.SearchFields = new Dictionary<string, string>()
55             {
56                 { nameof(TerritoryResponse.Name), "Name" },
57                 { nameof(TerritoryResponse.Square), "Square" },
58                 { nameof(TerritoryResponse.Description), "Description" },
59                 { nameof(TerritoryResponse.Type), "Type" },
60             };
61             List<TerritoryResponse> territories = await _territoriesService.GetFilteredTerritories(searchBy, searchString);
62 
63             ViewBag.CurrentSearchBy = searchBy;
64             ViewBag.CurrentSearchString = searchString;
65 
66             //Sort
67             List<TerritoryResponse> sortedTerritories = await _territoriesService.GetSortedTerritories(territories, sortBy, sortOrder);
68 
69             ViewBag.CurrentSortBy = sortBy.ToString();
70             ViewBag.CurrentSortOrder = sortOrder.ToString();
71 
72             //Id of authenticated user
73             var userClaims = User.Identity as ClaimsIdentity;
74             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
75 
76             List<TerritoryResponse> finalTerritories = new List<TerritoryResponse>();
77 
78             List<GuardExstensionsResponse> guardExstensionsList = await _guardExstensionsService.GetAllGuardExstensions();
79             Guid guardExstentionsId = new Guid();
80 
81             foreach(GuardExstensionsResponse guardExstensionsResponse in guardExstensionsList)
82             {
83                 if(Convert.ToString(guardExstensionsResponse.UserId) == userId)
84                     guardExstentionsId = guardExstensionsResponse.Id;
85             }
86             List<OrderGuards> orderGuards = await _context.OrderGuards.ToListAsync();
87             List<OrderGuards> finalOrderGuards = new List<OrderGuards>();
88             foreach(OrderGuards orderGuardsObject in orderGuards)
89             {
90                 if(orderGuardsObject.GuardExstensionsId == guardExstentionsId)
91                     finalOrderGuards.Add(orderGuardsObject);
92             }
93             List<OrderResponse> ordersList = await _ordersService.GetAllOrders();
94             List<OrderResponse> finalOrdersList = new List<OrderResponse>();
95             foreach(OrderResponse orderResponse in ordersList)
96             {
97                 foreach(OrderGuards orderGuardsObject in finalOrderGuards)
98                 {
99                     if(orderGuardsObject.OrderId == orderResponse.Id)
100                         finalOrdersList.Add(orderResponse);
101                 }
102             }
103 
104             List<TerritoryResponse> territoriesList = await _territoriesService.GetAllTerritories();
105 
106             foreach(TerritoryResponse territory in territoriesList)
107             {
108                 foreach(OrderResponse order in finalOrdersList)
109                 {
110                     if(territory.OwnerId == order.OwnerId)
111                         finalTerritories.Add(territory);
112                 }
113             }
114 
115             return View(finalTerritories);
116         }
117 
118         [HttpGet]
119         [Route("Orders")]
120         public async Task<IActionResult> Orders(string searchBy, string? searchString, string sortBy = nameof(TerritoryResponse.Name), SortOrderOptions sortOrder = SortOrderOptions.ASC)
121         {
122             ViewBag.SearchFields = new Dictionary<string, string>()
123             {
124                 { nameof(OrderResponse.TypeOfService), "TypeOfService" },
125                 { nameof(OrderResponse.SecurityLevel), "SecurityLevel" },
126             };
127             List<TerritoryResponse> territories = await _territoriesService.GetFilteredTerritories(searchBy, searchString);
128 
129             ViewBag.CurrentSearchBy = searchBy;
130             ViewBag.CurrentSearchString = searchString;
131 
132             //Sort
133             List<TerritoryResponse> sortedTerritories = await _territoriesService.GetSortedTerritories(territories, sortBy, sortOrder);
134 
135             ViewBag.CurrentSortBy = sortBy.ToString();
136             ViewBag.CurrentSortOrder = sortOrder.ToString();
137 
138             List<OrderResponse> orders = await _ordersService.GetAllOrders();
139             ViewBag.Order = orders;
140             return View(orders);
141         }
142 
143         [HttpGet]
144         [Route("AddOrder/{orderID}")]
145         public async Task<IActionResult> AddOrder(Guid orderID)
146         {
147             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderID);
148             if (orderResponse == null)
149                 return RedirectToAction("Index");
150             return View(orderResponse);
151         }
152 
153         [HttpPost]
154         [Route("AddOrder/{orderID}")]
155         public async Task<IActionResult> AddOrder(OrderResponse orderResponseToAdd)
156         {
157             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderResponseToAdd.Id);
158             if (orderResponse == null)
159                 return RedirectToAction("Index");
160 
161             var userClaims = User.Identity as ClaimsIdentity;
162             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
163             Guid userGuid = new Guid(userId);
164             GuardExstensions? guardExstensionsResponse = await _context.GuardExstensions.FirstOrDefaultAsync(x => x.UserId == userGuid);
165 
166             List<OrderGuardsResponse> orderGuardsResponses = await _orderGuardsService.GetAllOrderGuards();
167             List<OrderGuardsResponse> finalOrderGuardsResponses = new List<OrderGuardsResponse>();
168             foreach(OrderGuardsResponse orderGuardResponse in orderGuardsResponses)
169             {
170                 if(orderGuardResponse.GuardExstensionsId == guardExstensionsResponse.Id)
171                     finalOrderGuardsResponses.Add(orderGuardResponse);
172             }
173             bool isInOrder = false;
174             foreach(OrderGuardsResponse orderGuardsResponseObject in finalOrderGuardsResponses)
175             {
176                 if(orderGuardsResponseObject.OrderId == orderResponseToAdd.Id)
177                     isInOrder = true;
178             }
179 
180             if(!isInOrder)
181             {
182                 OrderGuardsAddRequest orderGuardsAddRequest = new OrderGuardsAddRequest();
183                 orderGuardsAddRequest.OrderId = orderResponseToAdd.Id;
184                 orderGuardsAddRequest.GuardExstensionsId = guardExstensionsResponse.Id;
185                 OrderGuardsResponse orderGuardsFinalResponse = await _orderGuardsService.AddOrderGuards(orderGuardsAddRequest);
186             }
187             return RedirectToAction("Index");
188         }
189 
190         [HttpGet]
191         [Route("ViewOrder/{territoryID}")]
192         public async Task<IActionResult> ViewOrderDetails(Guid territoryID)
193         {
194             string? ownerId = _context.Territories.Where(x => x.Id == territoryID).Select(x => x.OwnerId).FirstOrDefault().ToString();
195             Guid ownerGuid = new Guid(ownerId);
196             string? orderId = _context.Orders.Where(x => x.OwnerId == ownerGuid).Select(x => x.Id).FirstOrDefault().ToString();
197             Guid orderGuid = new Guid(orderId);
198             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderGuid);
199 
200             var userClaims = User.Identity as ClaimsIdentity;
201             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
202             Guid userGuid = new Guid(userId);
203             string? guardExstentionsId = _context.GuardExstensions.Where(x => x.UserId == userGuid).Select(x => x.Id).FirstOrDefault().ToString();
204             string? rankId = _context.GuardExstensions.Where(x => x.UserId == userGuid).Select(x => x.RankId).FirstOrDefault().ToString();
205             Guid rankGuid = new Guid(rankId);
206             string payPerHour = _context.Ranks.Where(x => x.Id == rankGuid).Select(x => x.PayPerHour).FirstOrDefault().ToString();
207 
208             double orientedPayPerHour = Convert.ToDouble(payPerHour);
209 
210             if (orderResponse.TypeOfService == ServiceTypeOptions.PlacementOnPosts.ToString())
211                 orientedPayPerHour = orientedPayPerHour * 1.1;
212             if (orderResponse.TypeOfService == ServiceTypeOptions.Patrol.ToString())
213                 orientedPayPerHour = orientedPayPerHour * 1.3;
214 
215             if (orderResponse.TypeOfService == SecurityLevelOptions.Medium.ToString())
216                 orientedPayPerHour = orientedPayPerHour * 1.3;
217             if (orderResponse.TypeOfService == SecurityLevelOptions.High.ToString())
218                 orientedPayPerHour = orientedPayPerHour * 1.5;
219 
220             ViewBag.OrientedPayPerHour = orientedPayPerHour;
221             ViewBag.OwnerEmail = _context.Users.Where(x => x.Id == ownerGuid).Select(x => x.Email).FirstOrDefault().ToString();
222             return View(orderResponse);
223         }
224 
225         [HttpPost]
226         [Route("ViewOrder/{territoryID}")]
227         public async Task<IActionResult> ViewOrderDetails(OrderResponse orderResponseToDelete)
228         {
229             string? orderGuardsId = _context.OrderGuards.Where(x => x.OrderId == orderResponseToDelete.Id).Select(x => x.Id).FirstOrDefault().ToString();
230             Guid orderGuardsGuid = new Guid(orderGuardsId);
231 
232             OrderGuardsResponse? orderGuardsResponse = await _orderGuardsService.GetOrderGuardsByOrderGuardsId(orderGuardsGuid);
233 
234             if (orderGuardsResponse == null)
235                 return RedirectToAction("Index");
236 
237             await _orderGuardsService.DeleteOrderGuards(orderGuardsResponse.Id);
238             return RedirectToAction("Index");
239         }
240         [HttpGet]
241         [Route("ViewReports/{territoryID}")]
242         public async Task<IActionResult> ViewReports(Guid territoryID)
243         {
244             ViewBag.SearchFields = new Dictionary<string, string>()
245             {
246                 { nameof(GuardReportResponse.Date), "Date" },
247                 { nameof(GuardReportResponse.Message), "Message" },
248                 { nameof(GuardReportResponse.Descriptions), "Descriptions" },
249             };
250 
251             string? ownerId = _context.Territories.Where(x => x.Id == territoryID).Select(x => x.OwnerId).FirstOrDefault().ToString();
252             Guid ownerGuid = new Guid(ownerId);
253             string? orderId = _context.Orders.Where(x => x.OwnerId == ownerGuid).Select(x => x.Id).FirstOrDefault().ToString();
254             Guid orderGuid = new Guid(orderId);
255             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderGuid);
256 
257             List<GuardReportResponse> guardReportResponseList = await _guardReportsService.GetAllGuardReports();
258             List<GuardReportResponse> finalGuardReportResponseList = new List<GuardReportResponse>();
259             foreach(GuardReportResponse guardReport in guardReportResponseList)
260             {
261                 if(guardReport.OrderId == orderResponse.Id)
262                 finalGuardReportResponseList.Add(guardReport);
263             }
264             ViewBag.TerritoryId = territoryID.ToString();
265             return View(finalGuardReportResponseList);
266         }
267         [HttpGet]
268         [Route("CreateReport/{territoryID}")]
269         public async Task<IActionResult> CreateReport(Guid territoryID)
270         {
271             string? ownerId = _context.Territories.Where(x => x.Id == territoryID).Select(x => x.OwnerId).FirstOrDefault().ToString();
272             Guid ownerGuid = new Guid(ownerId);
273             string? orderId = _context.Orders.Where(x => x.OwnerId == ownerGuid).Select(x => x.Id).FirstOrDefault().ToString();
274             Guid orderGuid = new Guid(orderId);
275             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderGuid);
276 
277             var userClaims = User.Identity as ClaimsIdentity;
278             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
279             Guid userGuid = new Guid(userId);
280             string? guardExstentionsId = _context.GuardExstensions.Where(x => x.UserId == userGuid).Select(x => x.Id).FirstOrDefault().ToString();
281 
282             GuardReportAddRequest guardReportAddRequest = new GuardReportAddRequest();
283             guardReportAddRequest.OrderId = orderGuid;
284             guardReportAddRequest.GuardExstensionsId = new Guid(guardExstentionsId);
285             guardReportAddRequest.Date = DateTime.Now;
286 
287             ViewBag.TerritoryId = territoryID;
288 
289             return View(guardReportAddRequest);
290         }
291         [HttpPost]
292         [Route("CreateReport/{territoryID}")]
293         public async Task<IActionResult> CreateReport(GuardReportAddRequest guardReportAddRequest)
294         {
295             GuardReportResponse guardReportResponse = await _guardReportsService.AddGuardReport(guardReportAddRequest);
296 
297             return RedirectToAction("Index");
298         }
299         [HttpGet]
300         [Route("MyEquipment/")]
301         public async Task<IActionResult> MyEquipment()
302         {
303             ViewBag.SearchFields = new Dictionary<string, string>()
304             {
305                 { nameof(EquipmentResponse.Name), "Name" },
306                 { nameof(EquipmentResponse.Type), "Type" },
307             };
308 
309             var userClaims = User.Identity as ClaimsIdentity;
310             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
311             var guardExstentionsId = _context.GuardExstensions.Where(x => x.UserId == new Guid(userId)).Select(x => x.Id).FirstOrDefault().ToString();
312 
313             List<EquipmentResponse> equipmentResponseList = await _equipmentService.GetAllEquipment();
314             List<EquipmentClaims> equipmentClaimsList = _context.EquipmentClaims.Where(x => x.GuardExstensionsId == new Guid(guardExstentionsId)).ToList();
315             List<EquipmentResponse> finalEquipmentResponseList = new List<EquipmentResponse>();
316             foreach(EquipmentClaims equipmentClaims in equipmentClaimsList)
317             {
318                 foreach(EquipmentResponse equipment in equipmentResponseList)
319                 {
320                     if(equipmentClaims.GuardExstensionsId == new Guid(guardExstentionsId) && equipmentClaims.EquipmentId == equipment.Id)
321                     {
322                         finalEquipmentResponseList.Add(equipment);
323                     }
324                 }
325             }
326 
327             return View(finalEquipmentResponseList);
328         }
329         [HttpGet]
330         [Route("AddEquipment")]
331         public async Task<IActionResult> AddEquipment()
332         {
333             ViewBag.SearchFields = new Dictionary<string, string>()
334             {
335                 { nameof(EquipmentResponse.Name), "Name" },
336                 { nameof(EquipmentResponse.Type), "Type" },
337             };
338 
339             List<EquipmentResponse> equipmentResponseList = await _equipmentService.GetAllEquipment();
340 
341             return View(equipmentResponseList);
342         }
343         [HttpGet]
344         [Route("EquipmentDetails/{equipmentID}")]
345         public async Task<IActionResult> EquipmentDetails(Guid equipmentID)
346         {
347             EquipmentResponse? equipmentResponse = await _equipmentService.GetEquipmentByEquipmentId(equipmentID);
348             if (equipmentResponse == null)
349                 return RedirectToAction("Index");
350 
351 
352             return View(equipmentResponse);
353         }
354         [HttpPost]
355         [Route("EquipmentDetails/{equipmentID}")]
356         public async Task<IActionResult> EquipmentDetails(EquipmentResponse equipmentResponse)
357         {
358             var userClaims = User.Identity as ClaimsIdentity;
359             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
360             var guardExstentionsId = _context.GuardExstensions.Where(x => x.UserId == new Guid(userId)).Select(x => x.Id).FirstOrDefault().ToString();
361 
362             EquipmentClaims? equipmentClaims = await _context.EquipmentClaims.FirstOrDefaultAsync(x => x.GuardExstensionsId == new Guid(guardExstentionsId) && x.EquipmentId == equipmentResponse.Id);
363             if (equipmentClaims == null)
364             {
365                 EquipmentClaimsAddRequest equipmentClaimsAddRequest = new EquipmentClaimsAddRequest();
366                 equipmentClaimsAddRequest.EquipmentId = equipmentResponse.Id;
367                 equipmentClaimsAddRequest.GuardExstensionsId = new Guid(guardExstentionsId);
368                 EquipmentClaimsResponse equipmentClaimsResponse = await _equipmentClaimsService.AddEquipmentClaims(equipmentClaimsAddRequest);
369 
370             }
371 
372             return RedirectToAction("MyEquipment");
373         }
374 
375         [HttpGet]
376         [Route("UnpinEquipment/{equipmentID}")]
377         public async Task<IActionResult> UnpinEquipment(Guid equipmentID)
378         {
379             var userClaims = User.Identity as ClaimsIdentity;
380             var userId = userClaims.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
381             var guardExstentionsId = _context.GuardExstensions.Where(x => x.UserId == new Guid(userId)).Select(x => x.Id).FirstOrDefault().ToString();
382 
383             EquipmentClaims? equipmentClaims = await _context.EquipmentClaims.FirstOrDefaultAsync(x => x.GuardExstensionsId == new Guid(guardExstentionsId) && x.EquipmentId == equipmentID);
384             EquipmentResponse? equipmentResponse = await _equipmentService.GetEquipmentByEquipmentId(equipmentID);
385             if (equipmentClaims != null)
386             {
387                 ViewBag.Name = equipmentResponse.Name;
388                 ViewBag.Type = equipmentResponse.Type;
389             }
390             return View(equipmentClaims);
391         }
392         [HttpPost]
393         [Route("UnpinEquipment/{equipmentID}")]
394         public async Task<IActionResult> UnpinEquipment(EquipmentClaims equipmentClaims)
395         {
396             bool deleteEqCl = await _equipmentClaimsService.DeleteEquipmentClaims(equipmentClaims.Id); 
397             return RedirectToAction("MyEquipment");
398         }
399         public async Task<IActionResult> Logout()
400         {
401             await _signInManager.SignOutAsync();
402             return RedirectToAction(nameof(HomeController.Login), "Home");
403         }
404     }
405 }

	В.3 Код контролеру для роботи із панеллю адміністратора:

	1 using Microsoft.AspNetCore.Identity;
2 using Microsoft.AspNetCore.Mvc;
3 using Microsoft.EntityFrameworkCore;
4 using Rotativa.AspNetCore;
5 using SecureAndObserve.Core.Domain.Entities;
6 using SecureAndObserve.Core.Domain.IdentityEntities;
7 using SecureAndObserve.Core.DTO;
8 using SecureAndObserve.Core.Enums;
9 using SecureAndObserve.Core.ServiceContracts;
10 using SecureAndObserve.Infrastructure.DbContext;
11 using SecureAndObserve.UI.Areas.Owner.Controllers;
12 using SecureAndObserve.UI.Controllers;
13 using System.Security.Claims;
14 
15 namespace SecureAndObserve.UI.Areas.Admin.Controllers
16 {
17     [Area("Admin")]
18     [Route("[controller]")]
19     public class AdminController : Controller
20     {
21         private readonly ITerritoriesService _territoriesService;
22         private readonly IOrdersService _ordersService;
23         private readonly IOrderGuardsService _orderGuardsService;
24         private readonly IGuardExstensionsService _guardExstensionsService;
25         private readonly IEquipmentService _equipmentService;
26         private readonly IRanksService _ranksService;
27         private readonly ILogger<OwnerController> _logger;
28         private readonly ApplicationDbContext _context;
29         private readonly SignInManager<ApplicationUser> _signInManager;
30 
31         public AdminController(ITerritoriesService territoriesService, ILogger<OwnerController> logger, ApplicationDbContext context, SignInManager<ApplicationUser> signInManager, IOrdersService ordersService, IOrderGuardsService orderGuardsService, IGuardExstensionsService guardExstensionsService, IRanksService ranksService, IEquipmentService equipmentService)
32         {
33             _territoriesService = territoriesService;
34             _logger = logger;
35             _context = context;
36             _signInManager = signInManager;
37             _ordersService = ordersService;
38             _orderGuardsService = orderGuardsService;
39             _guardExstensionsService = guardExstensionsService;
40             _ranksService = ranksService;
41             _equipmentService = equipmentService;
42         }
43 
44         [HttpGet]
45         [Route("Territories")]
46         public async Task<IActionResult> Territories(string searchBy, string? searchString, string sortBy = nameof(TerritoryResponse.Name), SortOrderOptions sortOrder = SortOrderOptions.ASC)
47         {
48             _logger.LogInformation("Index action method of PersonsController");
49             _logger.LogDebug($"searchBy: {searchBy}, searchString: {searchString}, sortOrder: {sortOrder}");
50             //Search
51             ViewBag.SearchFields = new Dictionary<string, string>()
52             {
53                 { nameof(TerritoryResponse.Name), "Name" },
54                 { nameof(TerritoryResponse.Square), "Square" },
55                 { nameof(TerritoryResponse.Description), "Description" },
56                 { nameof(TerritoryResponse.Type), "Type" },
57             };
58             List<TerritoryResponse> territories = await _territoriesService.GetFilteredTerritories(searchBy, searchString);
59 
60             ViewBag.CurrentSearchBy = searchBy;
61             ViewBag.CurrentSearchString = searchString;
62 
63             //Sort
64             List<TerritoryResponse> sortedTerritories = await _territoriesService.GetSortedTerritories(territories, sortBy, sortOrder);
65 
66             ViewBag.CurrentSortBy = sortBy.ToString();
67             ViewBag.CurrentSortOrder = sortOrder.ToString();
68             return View(sortedTerritories);
69         }
70         [HttpGet]
71         [Route("Territories/EditTerritory/{territoryID}")]
72         public async Task<IActionResult> EditTerritory(Guid territoryID)
73         {
74             TerritoryResponse? territoryResponse = await _territoriesService.GetTerritoryByTerritoryId(territoryID);
75             if (territoryResponse == null)
76             {
77                 return RedirectToAction("Territories");
78             }
79 
80             return View(territoryResponse);
81         }
82 
83         [HttpPost]
84         [Route("Territories/EditTerritory/{territoryID}")]
85         public async Task<IActionResult> EditTerritory(TerritoryResponse territoryResponse)
86         {
87             if (territoryResponse == null)
88             {
89                 return RedirectToAction("Territories");
90             }
91 
92             var territoryInDb = await _context.Territories.FirstOrDefaultAsync(x => x.Id == territoryResponse.Id);
93             if (ModelState.IsValid)
94             {
95                 if (territoryInDb != null)
96                 {
97                     territoryInDb.Name = territoryResponse.Name;
98                     territoryInDb.Square = territoryResponse.Square;
99                     territoryInDb.Description = territoryResponse.Description;
100                     territoryInDb.Type = territoryResponse.Type;
101                     await _context.SaveChangesAsync();
102                     return RedirectToAction("Territories", "Admin");
103                 }
104             }
105             else
106             {
107                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
108                 return View(territoryResponse);
109             }
110 
111             return View(territoryResponse);
112         }
113 
114         [HttpGet]
115         [Route("Territories/DeleteTerritory/{territoryID}")]
116         public async Task<IActionResult> DeleteTerritory(Guid territoryID)
117         {
118             TerritoryResponse? territoryResponse = await _territoriesService.GetTerritoryByTerritoryId(territoryID);
119             if (territoryResponse == null)
120             {
121                 return RedirectToAction("Territories");
122             }
123 
124             return View(territoryResponse);
125         }
126 
127         [HttpPost]
128         [Route("Territories/DeleteTerritory/{territoryID}")]
129         public async Task<IActionResult> DeleteTerritory(TerritoryResponse territory)
130         {
131             if (territory == null)
132             {
133                 return RedirectToAction("Territories");
134             }
135 
136             var territoryInDb = await _context.Territories.FirstOrDefaultAsync(x => x.Id == territory.Id);
137             if (ModelState.IsValid)
138             {
139                 if (territoryInDb != null)
140                 {
141                     Order? order = await _context.Orders.FirstOrDefaultAsync(x => x.OwnerId == territoryInDb.OwnerId);
142                     if (order != null)
143                     {
144                         List<OrderGuards> orderGuards = await _context.OrderGuards.Where(x => x.OrderId == order.Id).ToListAsync();
145                         List<GuardReport> guardReports = await _context.GuardReports.Where(x => x.OrderId == order.Id).ToListAsync();
146                         foreach(GuardReport guardReport in guardReports)
147                         {
148                             _context.GuardReports.Remove(guardReport);
149                         }
150                         foreach (OrderGuards orderGuard in orderGuards)
151                         {
152                             _context.OrderGuards.Remove(orderGuard);
153                         }
154                         _context.Orders.Remove(order);
155                         await _context.SaveChangesAsync();
156                     }
157                     _context.Territories.Remove(territoryInDb);
158                     await _context.SaveChangesAsync();
159                     return RedirectToAction("Territories", "Admin");
160                 }
161             }
162             else
163             {
164                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
165                 return View(territory);
166             }
167 
168             return View(territory);
169         }
170 
171         [HttpGet]
172         [Route("Orders")]
173         public async Task<IActionResult> Orders(string searchBy, string? searchString, string sortBy = nameof(TerritoryResponse.Name), SortOrderOptions sortOrder = SortOrderOptions.ASC)
174         {
175             _logger.LogInformation("Index action method of PersonsController");
176             _logger.LogDebug($"searchBy: {searchBy}, searchString: {searchString}, sortOrder: {sortOrder}");
177             //Search
178             ViewBag.SearchFields = new Dictionary<string, string>()
179             {
180                 { nameof(OrderResponse.OwnerId), "OwnerId" },
181                 { nameof(OrderResponse.TypeOfService), "TypeOfService" },
182                 { nameof(OrderResponse.SecurityLevel), "SecurityLevel" },
183             };
184             List<OrderResponse> orders = await _ordersService.GetAllOrders();
185 
186             ViewBag.CurrentSearchBy = searchBy;
187             ViewBag.CurrentSearchString = searchString;
188 
189             //Sort
190             List<OrderResponse> sortedOrders = orders;
191 
192             ViewBag.CurrentSortBy = sortBy.ToString();
193             ViewBag.CurrentSortOrder = sortOrder.ToString();
194             return View(sortedOrders);
195         }
196 
197         [HttpGet]
198         [Route("Orders/EditOrder/{orderID}")]
199         public async Task<IActionResult> EditOrder(Guid orderID)
200         {
201             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderID);
202             if (orderResponse == null)
203             {
204                 return RedirectToAction("Orders");
205             }
206 
207             return View(orderResponse);
208         }
209 
210         [HttpPost]
211         [Route("Orders/EditOrder/{orderID}")]
212         public async Task<IActionResult> EditOrder(OrderResponse orderResponse)
213         {
214             if (orderResponse == null)
215             {
216                 return RedirectToAction("Orders");
217             }
218 
219             var orderInDb = await _context.Orders.FirstOrDefaultAsync(x => x.Id == orderResponse.Id);
220             if (ModelState.IsValid)
221             {
222                 if (orderInDb != null)
223                 {
224                     orderInDb.OwnerId = orderResponse.OwnerId;
225                     orderInDb.SecurityLevel = orderResponse.SecurityLevel;
226                     orderInDb.TypeOfService = orderResponse.TypeOfService;
227                     await _context.SaveChangesAsync();
228                     return RedirectToAction("Orders", "Admin");
229                 }
230             }
231             else
232             {
233                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
234                 return View(orderResponse);
235             }
236 
237             return View(orderResponse);
238         }
239         [HttpGet]
240         [Route("Orders/DeleteOrder/{orderID}")]
241         public async Task<IActionResult> DeleteOrder(Guid orderID)
242         {
243             OrderResponse? orderResponse = await _ordersService.GetOrderByOrderId(orderID);
244             if (orderResponse == null)
245             {
246                 return RedirectToAction("Orders");
247             }
248 
249             return View(orderResponse);
250         }
251 
252         [HttpPost]
253         [Route("Orders/DeleteOrder/{orderID}")]
254         public async Task<IActionResult> DeleteOrder(OrderResponse orderToDelete)
255         {
256             if (orderToDelete == null)
257             {
258                 return RedirectToAction("Orders");
259             }
260 
261             if (ModelState.IsValid)
262             {
263                     Order? order = await _context.Orders.FirstOrDefaultAsync(x => x.Id == orderToDelete.Id);
264                     if (order != null)
265                     {
266                         List<OrderGuards> orderGuards = await _context.OrderGuards.Where(x => x.OrderId == order.Id).ToListAsync();
267                         List<GuardReport> guardReports = await _context.GuardReports.Where(x => x.OrderId == order.Id).ToListAsync();
268                         foreach (GuardReport guardReport in guardReports)
269                         {
270                             _context.GuardReports.Remove(guardReport);
271                         }
272                         foreach (OrderGuards orderGuard in orderGuards)
273                         {
274                             _context.OrderGuards.Remove(orderGuard);
275                         }
276                         _context.Orders.Remove(order);
277                         await _context.SaveChangesAsync();
278                     }
279                     await _context.SaveChangesAsync();
280                     return RedirectToAction("Orders", "Admin");
281                 }
282             else
283             {
284                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
285                 return View(orderToDelete);
286             }
287         }
288 
289         [HttpGet]
290         [Route("Ranks")]
291         public async Task<IActionResult> Ranks(string searchBy, string? searchString, string sortBy = nameof(TerritoryResponse.Name), SortOrderOptions sortOrder = SortOrderOptions.ASC)
292         {
293             _logger.LogInformation("Index action method of PersonsController");
294             _logger.LogDebug($"searchBy: {searchBy}, searchString: {searchString}, sortOrder: {sortOrder}");
295             //Search
296             ViewBag.SearchFields = new Dictionary<string, string>()
297             {
298                 { nameof(RankResponse.Name), "Name" },
299                 { nameof(RankResponse.PayPerHour), "PayPerHour" },
300                 { nameof(RankResponse.Description), "Description" },
301             };
302             List<RankResponse> ranks = await _ranksService.GetAllRanks();
303 
304             ViewBag.CurrentSearchBy = searchBy;
305             ViewBag.CurrentSearchString = searchString;
306 
307             //Sort
308             List<RankResponse> sortedRanks = ranks;
309 
310             ViewBag.CurrentSortBy = sortBy.ToString();
311             ViewBag.CurrentSortOrder = sortOrder.ToString();
312             return View(sortedRanks);
313         }
314 
315         [HttpGet]
316         [Route("Ranks/EditRank/{rankID}")]
317         public async Task<IActionResult> EditRank(Guid rankID)
318         {
319             RankResponse? rankResponse = await _ranksService.GetRankByRankId(rankID);
320             if (rankResponse == null)
321             {
322                 return RedirectToAction("Ranks");
323             }
324 
325             return View(rankResponse);
326         }
327         [HttpPost]
328         [Route("Ranks/EditRank/{rankID}")]
329         public async Task<IActionResult> EditRank(RankResponse rankResponse)
330         {
331             if (rankResponse == null)
332             {
333                 return RedirectToAction("Ranks");
334             }
335 
336             var rankInDb = await _context.Ranks.FirstOrDefaultAsync(x => x.Id == rankResponse.Id);
337             if (ModelState.IsValid)
338             {
339                 if (rankInDb != null)
340                 {
341                     rankInDb.Name = rankResponse.Name;
342                     rankInDb.PayPerHour = rankResponse.PayPerHour;
343                     rankInDb.Description = rankResponse.Description;
344                     await _context.SaveChangesAsync();
345                     return RedirectToAction("Ranks", "Admin");
346                 }
347             }
348             else
349             {
350                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
351                 return View(rankResponse);
352             }
353 
354             return View(rankResponse);
355         }
356 
357         [HttpGet]
358         [Route("Equipment")]
359         public async Task<IActionResult> Equipment(string searchBy, string? searchString, string sortBy = nameof(TerritoryResponse.Name), SortOrderOptions sortOrder = SortOrderOptions.ASC)
360         {
361             _logger.LogInformation("Index action method of PersonsController");
362             _logger.LogDebug($"searchBy: {searchBy}, searchString: {searchString}, sortOrder: {sortOrder}");
363             //Search
364             ViewBag.SearchFields = new Dictionary<string, string>()
365             {
366                 { nameof(EquipmentResponse.Name), "Name" },
367                 { nameof(EquipmentResponse.Type), "Type" },
368                 { nameof(EquipmentResponse.Amount), "Amount" },
369             };
370             List<EquipmentResponse> equipments = await _equipmentService.GetAllEquipment();
371 
372             ViewBag.CurrentSearchBy = searchBy;
373             ViewBag.CurrentSearchString = searchString;
374 
375             //Sort
376             List<EquipmentResponse> equpmentSort = equipments;
377 
378             ViewBag.CurrentSortBy = sortBy.ToString();
379             ViewBag.CurrentSortOrder = sortOrder.ToString();
380             return View(equpmentSort);
381         }
382 
383         [HttpGet]
384         [Route("Equipment/EditEquipment/{equipmentID}")]
385         public async Task<IActionResult> EditEquipment(Guid equipmentID)
386         {
387             EquipmentResponse? equipmentResponse = await _equipmentService.GetEquipmentByEquipmentId(equipmentID);
388             if (equipmentResponse == null)
389             {
390                 return RedirectToAction("Equipment");
391             }
392 
393             return View(equipmentResponse);
394         }
395         [HttpPost]
396         [Route("Equipment/EditEquipment/{equipmentID}")]
397         public async Task<IActionResult> EditEquipment(EquipmentResponse equipmentResponse)
398         {
399             if (equipmentResponse == null)
400             {
401                 return RedirectToAction("Equipment");
402             }
403 
404             var equipmentInDb = await _context.Equipment.FirstOrDefaultAsync(x => x.Id == equipmentResponse.Id);
405             if (ModelState.IsValid)
406             {
407                 if (equipmentInDb != null)
408                 {
409                     equipmentInDb.Name = equipmentResponse.Name;
410                     equipmentInDb.Type = equipmentResponse.Type;
411                     equipmentInDb.Amount = equipmentResponse.Amount;
412                     await _context.SaveChangesAsync();
413                     return RedirectToAction("Equipment", "Admin");
414                 }
415             }
416             else
417             {
418                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
419                 return View(equipmentResponse);
420             }
421 
422             return View(equipmentResponse);
423         }
424         [HttpGet]
425         [Route("Equipment/DeleteEquipment/{equipmentID}")]
426         public async Task<IActionResult> DeleteEquipment(Guid equipmentID)
427         {
428             EquipmentResponse? equipmentResponse = await _equipmentService.GetEquipmentByEquipmentId(equipmentID);
429             if (equipmentResponse == null)
430             {
431                 return RedirectToAction("Equipment");
432             }
433 
434             return View(equipmentResponse);
435         }
436         [HttpPost]
437         [Route("Equipment/DeleteEquipment/{equipmentID}")]
438         public async Task<IActionResult> DeleteEquipment(EquipmentResponse equipmentToDelete)
439         {
440             if (equipmentToDelete == null)
441             {
442                 return RedirectToAction("Equipment");
443             }
444 
445             if (ModelState.IsValid)
446             {
447                 Equipment? equipment = await _context.Equipment.FirstOrDefaultAsync(x => x.Id == equipmentToDelete.Id);
448                 if (equipment != null)
449                 {
450                     List<EquipmentClaims> equipmentClaims = await _context.EquipmentClaims.Where(x => x.EquipmentId == equipment.Id).ToListAsync();
451                     foreach (EquipmentClaims equipmentClaim in equipmentClaims)
452                     {
453                         _context.EquipmentClaims.Remove(equipmentClaim);
454                     }
455                     _context.Equipment.Remove(equipment);
456                     await _context.SaveChangesAsync();
457                 }
458                 await _context.SaveChangesAsync();
459                 return RedirectToAction("Equipment", "Admin");
460             }
461             else
462             {
463                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
464                 return View(equipmentToDelete);
465             }
466         }
467 
468         [HttpGet]
469         [Route("Equipment/AddEquipment/")]
470         public async Task<IActionResult> AddEquipment()
471         {
472             return View();
473         }
474 
475         [HttpPost]
476         [Route("Equipment/AddEquipment/")]
477         public async Task<IActionResult> AddEquipment(EquipmentAddRequest equipmentAddRequest)
478         {
479             if (!ModelState.IsValid)
480             {
481 
482                 ViewBag.Errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();
483                 return View(equipmentAddRequest);
484             }
485             //call the service method
486             EquipmentResponse equipmentResponse = await _equipmentService.AddEquipment(equipmentAddRequest);
487 
488             //navigate to Index() action method (its makes another get request to "owner/index")
489             return RedirectToAction("Equipment", "Admin");
490         }
491 
492 
493         [Route("Equipment/EquipmentPDF/")]
494         public async Task<IActionResult> EquipmentPDF()
495         {
496             List<EquipmentResponse> equipment = await _equipmentService.GetAllEquipment();
497 
498             //Return view as pdf
499             return new ViewAsPdf("EquipmentPDF", equipment, ViewData)
500             {
501                 PageMargins = new Rotativa.AspNetCore.Options.Margins()
502                 {
503                     Top = 20,
504                     Right = 20,
505                     Bottom = 20,
506                     Left = 20
507                 },
508                 PageOrientation = Rotativa.AspNetCore.Options.Orientation.Landscape
509             };
510         }
511         public async Task<IActionResult> Logout()
512         {
513             await _signInManager.SignOutAsync();
514             return RedirectToAction(nameof(HomeController.Login), "Home");
515         }
516     }
517 }

	
 
ДОДАТОК Г
Документ про перевірку на наявність плагіату
	Г.1 Перевірка на наявність плагіату (див. рис. Г.1 – Г.2)
 
Рисунок Г.1 – Перевірка на наявність плагіату
 
Рисунок Г.2 – Схожість із іншими студентами
